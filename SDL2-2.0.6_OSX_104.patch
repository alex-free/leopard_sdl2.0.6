Only in SDL2-2.0.6-tiger: Makefile
Only in SDL2-2.0.6-tiger: Makefile.rules
Only in SDL2-2.0.6-tiger: build
Only in SDL2-2.0.6-tiger: config.log
Only in SDL2-2.0.6-tiger: config.status
diff -ru SDL2-2.0.6-orig/configure SDL2-2.0.6-tiger/configure
--- SDL2-2.0.6-orig/configure	2017-09-22 20:51:01.000000000 +0200
+++ SDL2-2.0.6-tiger/configure	2018-05-25 16:24:49.000000000 +0200
@@ -24339,7 +24339,7 @@
 $as_echo "#define SDL_AUDIO_DRIVER_COREAUDIO 1" >>confdefs.h
 
             SOURCES="$SOURCES $srcdir/src/audio/coreaudio/*.m"
-            EXTRA_LDFLAGS="$EXTRA_LDFLAGS -Wl,-framework,CoreAudio -Wl,-framework,AudioToolbox"
+            EXTRA_LDFLAGS="$EXTRA_LDFLAGS -Wl,-framework,CoreAudio -Wl,-framework,AudioToolbox -Wl,-framework,AudioUnit"
             SUMMARY_audio="${SUMMARY_audio} coreaudio"
             have_audio=yes
         fi
diff -ru SDL2-2.0.6-orig/configure.in SDL2-2.0.6-tiger/configure.in
--- SDL2-2.0.6-orig/configure.in	2017-09-22 20:51:01.000000000 +0200
+++ SDL2-2.0.6-tiger/configure.in	2018-05-25 16:29:07.000000000 +0200
@@ -3722,7 +3722,7 @@
         if test x$enable_audio = xyes; then
             AC_DEFINE(SDL_AUDIO_DRIVER_COREAUDIO, 1, [ ])
             SOURCES="$SOURCES $srcdir/src/audio/coreaudio/*.m"
-            EXTRA_LDFLAGS="$EXTRA_LDFLAGS -Wl,-framework,CoreAudio -Wl,-framework,AudioToolbox"
+            EXTRA_LDFLAGS="$EXTRA_LDFLAGS -Wl,-framework,CoreAudio -Wl,-framework,AudioToolbox -Wl,-framework,AudioUnit"
             SUMMARY_audio="${SUMMARY_audio} coreaudio"
             have_audio=yes
         fi
diff -ru SDL2-2.0.6-orig/include/SDL_config.h SDL2-2.0.6-tiger/include/SDL_config.h
--- SDL2-2.0.6-orig/include/SDL_config.h	2017-09-22 20:51:01.000000000 +0200
+++ SDL2-2.0.6-tiger/include/SDL_config.h	2018-05-25 10:54:05.000000000 +0200
@@ -1,3 +1,4 @@
+/* include/SDL_config.h.  Generated from SDL_config.h.in by configure.  */
 /*
   Simple DirectMedia Layer
   Copyright (C) 1997-2017 Sam Lantinga <slouken@libsdl.org>
@@ -22,32 +23,371 @@
 #ifndef SDL_config_h_
 #define SDL_config_h_
 
-#include "SDL_platform.h"
-
 /**
- *  \file SDL_config.h
+ *  \file SDL_config.h.in
+ *
+ *  This is a set of defines to configure the SDL features
  */
 
-/* Add any platform that doesn't build using the configure system. */
-#if defined(__WIN32__)
-#include "SDL_config_windows.h"
-#elif defined(__WINRT__)
-#include "SDL_config_winrt.h"
-#elif defined(__MACOSX__)
-#include "SDL_config_macosx.h"
-#elif defined(__IPHONEOS__)
-#include "SDL_config_iphoneos.h"
-#elif defined(__ANDROID__)
-#include "SDL_config_android.h"
-#elif defined(__PSP__)
-#include "SDL_config_psp.h"
+/* General platform specific identifiers */
+#include "SDL_platform.h"
+
+/* Make sure that this isn't included by Visual C++ */
+#ifdef _MSC_VER
+#error You should run hg revert SDL_config.h 
+#endif
+
+/* C language features */
+/* #undef const */
+/* #undef inline */
+/* #undef volatile */
+
+/* C datatypes */
+#ifdef __LP64__
+#define SIZEOF_VOIDP 8
 #else
-/* This is a minimal configuration just to get SDL running on new platforms */
-#include "SDL_config_minimal.h"
-#endif /* platform config */
+#define SIZEOF_VOIDP 4
+#endif
+#define HAVE_GCC_ATOMICS 1
+/* #undef HAVE_GCC_SYNC_LOCK_TEST_AND_SET */
 
-#ifdef USING_GENERATED_CONFIG_H
-#error Wrong SDL_config.h, check your include path?
+/* Comment this if you want to build without any C library requirements */
+#define HAVE_LIBC 1
+#if HAVE_LIBC
+
+/* Useful headers */
+#define STDC_HEADERS 1
+#define HAVE_ALLOCA_H 1
+#define HAVE_CTYPE_H 1
+#define HAVE_FLOAT_H 1
+#define HAVE_ICONV_H 1
+#define HAVE_INTTYPES_H 1
+#define HAVE_LIMITS_H 1
+/* #undef HAVE_MALLOC_H */
+#define HAVE_MATH_H 1
+#define HAVE_MEMORY_H 1
+#define HAVE_SIGNAL_H 1
+#define HAVE_STDARG_H 1
+#define HAVE_STDINT_H 1
+#define HAVE_STDIO_H 1
+#define HAVE_STDLIB_H 1
+#define HAVE_STRINGS_H 1
+#define HAVE_STRING_H 1
+#define HAVE_SYS_TYPES_H 1
+#define HAVE_WCHAR_H 1
+/* #undef HAVE_PTHREAD_NP_H */
+
+/* C library functions */
+#define HAVE_MALLOC 1
+#define HAVE_CALLOC 1
+#define HAVE_REALLOC 1
+#define HAVE_FREE 1
+#define HAVE_ALLOCA 1
+#ifndef __WIN32__ /* Don't use C runtime versions of these on Windows */
+#define HAVE_GETENV 1
+#define HAVE_SETENV 1
+#define HAVE_PUTENV 1
+#define HAVE_UNSETENV 1
 #endif
+#define HAVE_QSORT 1
+#define HAVE_ABS 1
+#define HAVE_BCOPY 1
+#define HAVE_MEMSET 1
+#define HAVE_MEMCPY 1
+#define HAVE_MEMMOVE 1
+#define HAVE_MEMCMP 1
+#define HAVE_WCSLEN 1
+/* #undef HAVE_WCSLCPY */
+/* #undef HAVE_WCSLCAT */
+#define HAVE_WCSCMP 1
+#define HAVE_STRLEN 1
+#define HAVE_STRLCPY 1
+#define HAVE_STRLCAT 1
+#define HAVE_STRDUP 1
+/* #undef HAVE__STRREV */
+/* #undef HAVE__STRUPR */
+/* #undef HAVE__STRLWR */
+/* #undef HAVE_INDEX */
+/* #undef HAVE_RINDEX */
+#define HAVE_STRCHR 1
+#define HAVE_STRRCHR 1
+#define HAVE_STRSTR 1
+/* #undef HAVE_ITOA */
+/* #undef HAVE__LTOA */
+/* #undef HAVE__UITOA */
+/* #undef HAVE__ULTOA */
+#define HAVE_STRTOL 1
+#define HAVE_STRTOUL 1
+/* #undef HAVE__I64TOA */
+/* #undef HAVE__UI64TOA */
+#define HAVE_STRTOLL 1
+#define HAVE_STRTOULL 1
+#define HAVE_STRTOD 1
+#define HAVE_ATOI 1
+#define HAVE_ATOF 1
+#define HAVE_STRCMP 1
+#define HAVE_STRNCMP 1
+/* #undef HAVE__STRICMP */
+#define HAVE_STRCASECMP 1
+/* #undef HAVE__STRNICMP */
+#define HAVE_STRNCASECMP 1
+/* #undef HAVE_SSCANF */
+#define HAVE_VSSCANF 1
+/* #undef HAVE_SNPRINTF */
+#define HAVE_VSNPRINTF 1
+#define HAVE_M_PI /**/
+#define HAVE_ATAN 1
+#define HAVE_ATAN2 1
+#define HAVE_ACOS 1
+#define HAVE_ASIN 1
+#define HAVE_CEIL 1
+#define HAVE_COPYSIGN 1
+#define HAVE_COS 1
+#define HAVE_COSF 1
+#define HAVE_FABS 1
+#define HAVE_FLOOR 1
+#define HAVE_LOG 1
+#define HAVE_POW 1
+#define HAVE_SCALBN 1
+#define HAVE_SIN 1
+#define HAVE_SINF 1
+#define HAVE_SQRT 1
+#define HAVE_SQRTF 1
+#define HAVE_TAN 1
+#define HAVE_TANF 1
+/* #undef HAVE_FOPEN64 */
+#define HAVE_FSEEKO 1
+/* #undef HAVE_FSEEKO64 */
+#define HAVE_SIGACTION 1
+#define HAVE_SA_SIGACTION 1
+#define HAVE_SETJMP 1
+#define HAVE_NANOSLEEP 1
+#define HAVE_SYSCONF 1
+#define HAVE_SYSCTLBYNAME 1
+/* #undef HAVE_CLOCK_GETTIME */
+/* #undef HAVE_GETPAGESIZE */
+#define HAVE_MPROTECT 1
+#define HAVE_ICONV 1
+/* #undef HAVE_PTHREAD_SETNAME_NP */
+/* #undef HAVE_PTHREAD_SET_NAME_NP */
+/* #undef HAVE_SEM_TIMEDWAIT */
+/* #undef HAVE_GETAUXVAL */
+#define HAVE_POLL 1
+
+#else
+#define HAVE_STDARG_H 1
+#define HAVE_STDDEF_H 1
+#define HAVE_STDINT_H 1
+#endif /* HAVE_LIBC */
+
+#define HAVE_ALTIVEC_H 1
+/* #undef HAVE_LIBUDEV_H */
+/* #undef HAVE_DBUS_DBUS_H */
+/* #undef HAVE_IBUS_IBUS_H */
+/* #undef HAVE_FCITX_FRONTEND_H */
+/* #undef HAVE_LIBSAMPLERATE_H */
+
+/* #undef HAVE_DDRAW_H */
+/* #undef HAVE_DINPUT_H */
+/* #undef HAVE_DSOUND_H */
+/* #undef HAVE_DXGI_H */
+/* #undef HAVE_XINPUT_H */
+/* #undef HAVE_XINPUT_GAMEPAD_EX */
+/* #undef HAVE_XINPUT_STATE_EX */
+
+/* SDL internal assertion support */
+/* #undef SDL_DEFAULT_ASSERT_LEVEL */
+
+/* Allow disabling of core subsystems */
+/* #undef SDL_ATOMIC_DISABLED */
+/* #undef SDL_AUDIO_DISABLED */
+/* #undef SDL_CPUINFO_DISABLED */
+/* #undef SDL_EVENTS_DISABLED */
+/* #undef SDL_FILE_DISABLED */
+#define SDL_JOYSTICK_DISABLED 1
+#define SDL_HAPTIC_DISABLED 1
+/* #undef SDL_LOADSO_DISABLED */
+/* #undef SDL_RENDER_DISABLED */
+/* #undef SDL_THREADS_DISABLED */
+/* #undef SDL_TIMERS_DISABLED */
+/* #undef SDL_VIDEO_DISABLED */
+/* #undef SDL_POWER_DISABLED */
+/* #undef SDL_FILESYSTEM_DISABLED */
+
+/* Enable various audio drivers */
+/* #undef SDL_AUDIO_DRIVER_ALSA */
+/* #undef SDL_AUDIO_DRIVER_ALSA_DYNAMIC */
+/* #undef SDL_AUDIO_DRIVER_ANDROID */
+/* #undef SDL_AUDIO_DRIVER_ARTS */
+/* #undef SDL_AUDIO_DRIVER_ARTS_DYNAMIC */
+#define SDL_AUDIO_DRIVER_COREAUDIO 1
+#define SDL_AUDIO_DRIVER_DISK 1
+/* #undef SDL_AUDIO_DRIVER_DSOUND */
+#define SDL_AUDIO_DRIVER_DUMMY 1
+/* #undef SDL_AUDIO_DRIVER_EMSCRIPTEN */
+/* #undef SDL_AUDIO_DRIVER_ESD */
+/* #undef SDL_AUDIO_DRIVER_ESD_DYNAMIC */
+/* #undef SDL_AUDIO_DRIVER_FUSIONSOUND */
+/* #undef SDL_AUDIO_DRIVER_FUSIONSOUND_DYNAMIC */
+/* #undef SDL_AUDIO_DRIVER_HAIKU */
+/* #undef SDL_AUDIO_DRIVER_JACK */
+/* #undef SDL_AUDIO_DRIVER_JACK_DYNAMIC */
+/* #undef SDL_AUDIO_DRIVER_NACL */
+/* #undef SDL_AUDIO_DRIVER_NAS */
+/* #undef SDL_AUDIO_DRIVER_NAS_DYNAMIC */
+/* #undef SDL_AUDIO_DRIVER_NETBSD */
+/* #undef SDL_AUDIO_DRIVER_OSS */
+/* #undef SDL_AUDIO_DRIVER_OSS_SOUNDCARD_H */
+/* #undef SDL_AUDIO_DRIVER_PAUDIO */
+/* #undef SDL_AUDIO_DRIVER_PULSEAUDIO */
+/* #undef SDL_AUDIO_DRIVER_PULSEAUDIO_DYNAMIC */
+/* #undef SDL_AUDIO_DRIVER_QSA */
+/* #undef SDL_AUDIO_DRIVER_SNDIO */
+/* #undef SDL_AUDIO_DRIVER_SNDIO_DYNAMIC */
+/* #undef SDL_AUDIO_DRIVER_SUNAUDIO */
+/* #undef SDL_AUDIO_DRIVER_WASAPI */
+/* #undef SDL_AUDIO_DRIVER_WINMM */
+/* #undef SDL_AUDIO_DRIVER_XAUDIO2 */
+
+/* Enable various input drivers */
+/* #undef SDL_INPUT_LINUXEV */
+/* #undef SDL_INPUT_LINUXKD */
+/* #undef SDL_INPUT_TSLIB */
+/* #undef SDL_JOYSTICK_HAIKU */
+/* #undef SDL_JOYSTICK_DINPUT */
+/* #undef SDL_JOYSTICK_XINPUT */
+/* #undef SDL_JOYSTICK_DUMMY */
+/* #undef SDL_JOYSTICK_IOKIT */
+/* #undef SDL_JOYSTICK_LINUX */
+/* #undef SDL_JOYSTICK_ANDROID */
+/* #undef SDL_JOYSTICK_WINMM */
+/* #undef SDL_JOYSTICK_USBHID */
+/* #undef SDL_JOYSTICK_USBHID_MACHINE_JOYSTICK_H */
+/* #undef SDL_JOYSTICK_EMSCRIPTEN */
+/* #undef SDL_HAPTIC_DUMMY */
+/* #undef SDL_HAPTIC_LINUX */
+/* #undef SDL_HAPTIC_IOKIT */
+/* #undef SDL_HAPTIC_DINPUT */
+/* #undef SDL_HAPTIC_XINPUT */
+
+/* Enable various shared object loading systems */
+#define SDL_LOADSO_DLOPEN 1
+/* #undef SDL_LOADSO_DUMMY */
+/* #undef SDL_LOADSO_LDG */
+/* #undef SDL_LOADSO_WINDOWS */
+
+/* Enable various threading systems */
+#define SDL_THREAD_PTHREAD 1
+#define SDL_THREAD_PTHREAD_RECURSIVE_MUTEX 1
+/* #undef SDL_THREAD_PTHREAD_RECURSIVE_MUTEX_NP */
+/* #undef SDL_THREAD_WINDOWS */
+
+/* Enable various timer systems */
+/* #undef SDL_TIMER_HAIKU */
+/* #undef SDL_TIMER_DUMMY */
+#define SDL_TIMER_UNIX 1
+/* #undef SDL_TIMER_WINDOWS */
+
+/* Enable various video drivers */
+/* #undef SDL_VIDEO_DRIVER_HAIKU */
+#define SDL_VIDEO_DRIVER_COCOA 1
+/* #undef SDL_VIDEO_DRIVER_DIRECTFB */
+/* #undef SDL_VIDEO_DRIVER_DIRECTFB_DYNAMIC */
+#define SDL_VIDEO_DRIVER_DUMMY 1
+/* #undef SDL_VIDEO_DRIVER_WINDOWS */
+/* #undef SDL_VIDEO_DRIVER_WAYLAND */
+/* #undef SDL_VIDEO_DRIVER_WAYLAND_QT_TOUCH */
+/* #undef SDL_VIDEO_DRIVER_WAYLAND_DYNAMIC */
+/* #undef SDL_VIDEO_DRIVER_WAYLAND_DYNAMIC_EGL */
+/* #undef SDL_VIDEO_DRIVER_WAYLAND_DYNAMIC_CURSOR */
+/* #undef SDL_VIDEO_DRIVER_WAYLAND_DYNAMIC_XKBCOMMON */
+/* #undef SDL_VIDEO_DRIVER_MIR */
+/* #undef SDL_VIDEO_DRIVER_MIR_DYNAMIC */
+/* #undef SDL_VIDEO_DRIVER_MIR_DYNAMIC_XKBCOMMON */
+#define SDL_VIDEO_DRIVER_X11 1
+/* #undef SDL_VIDEO_DRIVER_RPI */
+/* #undef SDL_VIDEO_DRIVER_KMSDRM */
+/* #undef SDL_VIDEO_DRIVER_KMSDRM_DYNAMIC */
+/* #undef SDL_VIDEO_DRIVER_KMSDRM_DYNAMIC_GBM */
+/* #undef SDL_VIDEO_DRIVER_ANDROID */
+/* #undef SDL_VIDEO_DRIVER_EMSCRIPTEN */
+#define SDL_VIDEO_DRIVER_X11_DYNAMIC "/usr/X11R6/lib/libX11.6.dylib"
+#define SDL_VIDEO_DRIVER_X11_DYNAMIC_XEXT "/usr/X11R6/lib/libXext.6.dylib"
+#define SDL_VIDEO_DRIVER_X11_DYNAMIC_XCURSOR "/usr/X11R6/lib/libXcursor.1.dylib"
+#define SDL_VIDEO_DRIVER_X11_DYNAMIC_XINERAMA "/usr/X11R6/lib/libXinerama.1.dylib"
+/* #undef SDL_VIDEO_DRIVER_X11_DYNAMIC_XINPUT2 */
+/* #undef SDL_VIDEO_DRIVER_X11_DYNAMIC_XRANDR */
+#define SDL_VIDEO_DRIVER_X11_DYNAMIC_XSS "/usr/X11R6/lib/libXss.1.dylib"
+#define SDL_VIDEO_DRIVER_X11_DYNAMIC_XVIDMODE "/usr/X11R6/lib/libXxf86vm.1.dylib"
+#define SDL_VIDEO_DRIVER_X11_XCURSOR 1
+#define SDL_VIDEO_DRIVER_X11_XDBE 1
+#define SDL_VIDEO_DRIVER_X11_XINERAMA 1
+/* #undef SDL_VIDEO_DRIVER_X11_XINPUT2 */
+/* #undef SDL_VIDEO_DRIVER_X11_XINPUT2_SUPPORTS_MULTITOUCH */
+/* #undef SDL_VIDEO_DRIVER_X11_XRANDR */
+#define SDL_VIDEO_DRIVER_X11_XSCRNSAVER 1
+#define SDL_VIDEO_DRIVER_X11_XSHAPE 1
+#define SDL_VIDEO_DRIVER_X11_XVIDMODE 1
+/* #undef SDL_VIDEO_DRIVER_X11_SUPPORTS_GENERIC_EVENTS */
+/* #undef SDL_VIDEO_DRIVER_X11_CONST_PARAM_XEXTADDDISPLAY */
+#define SDL_VIDEO_DRIVER_X11_HAS_XKBKEYCODETOKEYSYM 1
+/* #undef SDL_VIDEO_DRIVER_NACL */
+/* #undef SDL_VIDEO_DRIVER_VIVANTE */
+/* #undef SDL_VIDEO_DRIVER_VIVANTE_VDK */
+/* #undef SDL_VIDEO_DRIVER_QNX */
+
+/* #undef SDL_VIDEO_RENDER_D3D */
+/* #undef SDL_VIDEO_RENDER_D3D11 */
+#define SDL_VIDEO_RENDER_OGL 1
+/* #undef SDL_VIDEO_RENDER_OGL_ES */
+/* #undef SDL_VIDEO_RENDER_OGL_ES2 */
+/* #undef SDL_VIDEO_RENDER_DIRECTFB */
+
+/* Enable OpenGL support */
+#define SDL_VIDEO_OPENGL 1
+/* #undef SDL_VIDEO_OPENGL_ES */
+/* #undef SDL_VIDEO_OPENGL_ES2 */
+/* #undef SDL_VIDEO_OPENGL_BGL */
+#define SDL_VIDEO_OPENGL_CGL 1
+/* #undef SDL_VIDEO_OPENGL_EGL */
+#define SDL_VIDEO_OPENGL_GLX 1
+/* #undef SDL_VIDEO_OPENGL_WGL */
+/* #undef SDL_VIDEO_OPENGL_OSMESA */
+/* #undef SDL_VIDEO_OPENGL_OSMESA_DYNAMIC */
+
+/* Enable Vulkan support */
+/* #undef SDL_VIDEO_VULKAN */
+
+/* Enable system power support */
+/* #undef SDL_POWER_LINUX */
+/* #undef SDL_POWER_WINDOWS */
+#define SDL_POWER_MACOSX 1
+/* #undef SDL_POWER_HAIKU */
+/* #undef SDL_POWER_ANDROID */
+/* #undef SDL_POWER_EMSCRIPTEN */
+/* #undef SDL_POWER_HARDWIRED */
+
+/* Enable system filesystem support */
+/* #undef SDL_FILESYSTEM_HAIKU */
+#define SDL_FILESYSTEM_COCOA 1
+/* #undef SDL_FILESYSTEM_DUMMY */
+/* #undef SDL_FILESYSTEM_UNIX */
+/* #undef SDL_FILESYSTEM_WINDOWS */
+/* #undef SDL_FILESYSTEM_NACL */
+/* #undef SDL_FILESYSTEM_ANDROID */
+/* #undef SDL_FILESYSTEM_EMSCRIPTEN */
+
+/* Enable assembly routines */
+#define SDL_ASSEMBLY_ROUTINES 1
+#define SDL_ALTIVEC_BLITTERS 1
+
+/* Enable ime support */
+/* #undef SDL_USE_IME */
+
+/* Enable dynamic udev support */
+/* #undef SDL_UDEV_DYNAMIC */
+
+/* Enable dynamic libsamplerate support */
+/* #undef SDL_LIBSAMPLERATE_DYNAMIC */
 
 #endif /* SDL_config_h_ */
diff -ru SDL2-2.0.6-orig/include/SDL_platform.h SDL2-2.0.6-tiger/include/SDL_platform.h
--- SDL2-2.0.6-orig/include/SDL_platform.h	2017-09-22 20:51:01.000000000 +0200
+++ SDL2-2.0.6-tiger/include/SDL_platform.h	2018-05-24 21:19:35.000000000 +0200
@@ -84,7 +84,9 @@
 #undef __MACOSX__
 #define __MACOSX__  1
 #if MAC_OS_X_VERSION_MIN_REQUIRED < 1060
+#if 0
 # error SDL for Mac OS X only supports deploying on 10.6 and above.
+#endif
 #endif /* MAC_OS_X_VERSION_MIN_REQUIRED < 1060 */
 #endif /* TARGET_OS_IPHONE */
 #endif /* defined(__APPLE__) */
diff -ru SDL2-2.0.6-orig/include/SDL_syswm.h SDL2-2.0.6-tiger/include/SDL_syswm.h
--- SDL2-2.0.6-orig/include/SDL_syswm.h	2017-09-22 20:51:01.000000000 +0200
+++ SDL2-2.0.6-tiger/include/SDL_syswm.h	2018-05-24 21:19:35.000000000 +0200
@@ -229,21 +229,29 @@
 #if defined(SDL_VIDEO_DRIVER_COCOA)
         struct
         {
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
 #if defined(__OBJC__) && defined(__has_feature) && __has_feature(objc_arc)
             NSWindow __unsafe_unretained *window; /**< The Cocoa window */
 #else
             NSWindow *window;                     /**< The Cocoa window */
 #endif
+#else
+            NSWindow *window;                     /**< The Cocoa window */
+#endif
         } cocoa;
 #endif
 #if defined(SDL_VIDEO_DRIVER_UIKIT)
         struct
         {
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
 #if defined(__OBJC__) && defined(__has_feature) && __has_feature(objc_arc)
             UIWindow __unsafe_unretained *window; /**< The UIKit window */
 #else
             UIWindow *window;                     /**< The UIKit window */
 #endif
+#else
+            UIWindow *window;                     /**< The UIKit window */
+#endif
             GLuint framebuffer; /**< The GL view's Framebuffer Object. It must be bound when rendering to the screen using GL. */
             GLuint colorbuffer; /**< The GL view's color Renderbuffer Object. It must be bound when SDL_GL_SwapWindow is called. */
             GLuint resolveFramebuffer; /**< The Framebuffer Object which holds the resolve color Renderbuffer, when MSAA is used. */
Only in SDL2-2.0.6-tiger: libtool
Only in SDL2-2.0.6-tiger: sdl2-config
Only in SDL2-2.0.6-tiger: sdl2-config.cmake
Only in SDL2-2.0.6-tiger: sdl2.pc
diff -ru SDL2-2.0.6-orig/src/atomic/SDL_spinlock.c SDL2-2.0.6-tiger/src/atomic/SDL_spinlock.c
--- SDL2-2.0.6-orig/src/atomic/SDL_spinlock.c	2017-09-22 20:51:01.000000000 +0200
+++ SDL2-2.0.6-tiger/src/atomic/SDL_spinlock.c	2018-05-24 21:19:35.000000000 +0200
@@ -28,6 +28,10 @@
 #include "SDL_mutex.h"
 #include "SDL_timer.h"
 
+#if defined(__MACOSX__) || defined(__IPHONEOS__)
+#include <libkern/OSAtomic.h>
+#endif
+
 #if !defined(HAVE_GCC_ATOMICS) && defined(__SOLARIS__)
 #include <atomic.h>
 #endif
diff -ru SDL2-2.0.6-orig/src/audio/coreaudio/SDL_coreaudio.h SDL2-2.0.6-tiger/src/audio/coreaudio/SDL_coreaudio.h
--- SDL2-2.0.6-orig/src/audio/coreaudio/SDL_coreaudio.h	2017-09-22 20:51:01.000000000 +0200
+++ SDL2-2.0.6-tiger/src/audio/coreaudio/SDL_coreaudio.h	2018-05-25 10:10:35.000000000 +0200
@@ -29,6 +29,13 @@
 #define MACOSX_COREAUDIO 1
 #endif
 
+#if defined(__ALTIVEC__) && !defined(MAC_OS_X_VERSION_10_5)
+/* to cricumvent a bug in Mac OS X 10.4 SDK */
+#define vector __vector
+#include <CoreServices/CoreServices.h>
+#undef vector
+#endif
+
 #if MACOSX_COREAUDIO
 #include <CoreAudio/CoreAudio.h>
 #include <CoreServices/CoreServices.h>
@@ -46,8 +53,13 @@
 struct SDL_PrivateAudioData
 {
     SDL_Thread *thread;
+#if defined(MAC_OS_X_VERSION_10_5)
     AudioQueueRef audioQueue;
     AudioQueueBufferRef *audioBuffer;
+#else
+    AudioUnit audioUnit;
+    int audioUnitOpened;
+#endif
     void *buffer;
     UInt32 bufferOffset;
     UInt32 bufferSize;
diff -ru SDL2-2.0.6-orig/src/audio/coreaudio/SDL_coreaudio.m SDL2-2.0.6-tiger/src/audio/coreaudio/SDL_coreaudio.m
--- SDL2-2.0.6-orig/src/audio/coreaudio/SDL_coreaudio.m	2017-09-22 20:51:01.000000000 +0200
+++ SDL2-2.0.6-tiger/src/audio/coreaudio/SDL_coreaudio.m	2018-05-25 16:09:47.000000000 +0200
@@ -41,6 +41,38 @@
     }
 
 #if MACOSX_COREAUDIO
+#if !defined(MAC_OS_X_VERSION_10_5)
+#if 0
+typedef void (*addDevFn)(const char *name, AudioDeviceID devId, void *data);
+
+static void
+addToDevList(const char *name, AudioDeviceID devId, void *data)
+{
+    SDL_AddAudioDevice addfn = (SDL_AddAudioDevice) data;
+    addfn(name);
+}
+#endif
+
+typedef struct
+{
+    const char *findname;
+    AudioDeviceID devId;
+    int found;
+} FindDevIdData;
+ 
+static void
+findDevId(const char *name, const int iscapture, AudioDeviceID devId, void *_data)
+{
+    FindDevIdData *data = (FindDevIdData *) _data;
+    if (!data->found) {
+        if (SDL_strcmp(name, data->findname) == 0) {
+            data->found = 1;
+            data->devId = devId;
+        }
+    }
+}
+#endif
+
 static const AudioObjectPropertyAddress devlist_address = {
     kAudioHardwarePropertyDevices,
     kAudioObjectPropertyScopeGlobal,
@@ -213,6 +245,72 @@
     build_device_list(SDL_FALSE, addToDevList, NULL);
 }
 
+
+#if !defined(MAC_OS_X_VERSION_10_5)
+static int
+find_device_by_name(_THIS, const char *devname, int iscapture)
+{
+    AudioDeviceID devid = 0;
+    OSStatus result = noErr;
+    UInt32 size = 0;
+    UInt32 alive = 0;
+    pid_t pid = 0;
+
+    AudioObjectPropertyAddress addr = {
+        0,
+        kAudioObjectPropertyScopeGlobal,
+        kAudioObjectPropertyElementMaster
+    };
+
+    if (devname == NULL) {
+        size = sizeof (AudioDeviceID);
+        addr.mSelector =
+            ((iscapture) ? kAudioHardwarePropertyDefaultInputDevice :
+            kAudioHardwarePropertyDefaultOutputDevice);
+        result = AudioObjectGetPropertyData(kAudioObjectSystemObject, &addr,
+                                            0, NULL, &size, &devid);
+        CHECK_RESULT("AudioHardwareGetProperty (default device)");
+    } else {
+        FindDevIdData data;
+        SDL_zero(data);
+        data.findname = devname;
+        build_device_list(iscapture, findDevId, &data);
+        if (!data.found) {
+            SDL_SetError("CoreAudio: No such audio device.");
+            return 0;
+        }
+        devid = data.devId;
+    }
+
+    addr.mSelector = kAudioDevicePropertyDeviceIsAlive;
+    addr.mScope = iscapture ? kAudioDevicePropertyScopeInput :
+                    kAudioDevicePropertyScopeOutput;
+
+    size = sizeof (alive);
+    result = AudioObjectGetPropertyData(devid, &addr, 0, NULL, &size, &alive);
+    CHECK_RESULT
+        ("AudioDeviceGetProperty (kAudioDevicePropertyDeviceIsAlive)");
+
+    if (!alive) {
+        SDL_SetError("CoreAudio: requested device exists, but isn't alive.");
+        return 0;
+    }
+
+    addr.mSelector = kAudioDevicePropertyHogMode;
+    size = sizeof (pid);
+    result = AudioObjectGetPropertyData(devid, &addr, 0, NULL, &size, &pid);
+
+    /* some devices don't support this property, so errors are fine here. */
+    if ((result == noErr) && (pid != -1)) {
+        SDL_SetError("CoreAudio: requested device is being hogged.");
+        return 0;
+    }
+
+    this->hidden->deviceID = devid;
+    return 1;
+}
+#endif
+
 static void
 build_device_change_list(const char *name, const int iscapture, AudioDeviceID devId, void *data)
 {
@@ -404,6 +502,7 @@
 #endif
 
 
+#if defined(MAC_OS_X_VERSION_10_5)
 /* The AudioQueue callback */
 static void
 outputCallback(void *inUserData, AudioQueueRef inAQ, AudioQueueBufferRef inBuffer)
@@ -486,6 +585,81 @@
     AudioQueueEnqueueBuffer(this->hidden->audioQueue, inBuffer, 0, NULL);
 }
 
+#else
+/* OS X 10.4 stuff */
+/* The CoreAudio callback */
+static OSStatus
+outputCallback(void *inRefCon,
+               AudioUnitRenderActionFlags * ioActionFlags,
+               const AudioTimeStamp * inTimeStamp,
+               UInt32 inBusNumber, UInt32 inNumberFrames,
+               AudioBufferList * ioData)
+{
+    SDL_AudioDevice *this = (SDL_AudioDevice *) inRefCon;
+    AudioBuffer *abuf;
+    UInt32 remaining, len;
+    void *ptr;
+    UInt32 i;
+
+    /* Only do anything if audio is enabled and not paused */
+    if (!SDL_AtomicGet(&this->enabled) || SDL_AtomicGet(&this->paused)) {
+    /*if (!this->enabled || this->paused) {*/
+        for (i = 0; i < ioData->mNumberBuffers; i++) {
+            abuf = &ioData->mBuffers[i];
+            SDL_memset(abuf->mData, this->spec.silence, abuf->mDataByteSize);
+        }
+        return 0;
+    }
+
+    /* No SDL conversion should be needed here, ever, since we accept
+       any input format in OpenAudio, and leave the conversion to CoreAudio.
+     */
+    /*
+       SDL_assert(!this->convert.needed);
+       SDL_assert(this->spec.channels == ioData->mNumberChannels);
+     */
+
+    for (i = 0; i < ioData->mNumberBuffers; i++) {
+        abuf = &ioData->mBuffers[i];
+        remaining = abuf->mDataByteSize;
+        ptr = abuf->mData;
+        while (remaining > 0) {
+            if (this->hidden->bufferOffset >= this->hidden->bufferSize) {
+                /* Generate the data */
+                SDL_LockMutex(this->mixer_lock);
+                (*this->spec.callback)(this->spec.userdata,
+                            this->hidden->buffer, this->hidden->bufferSize);
+                SDL_UnlockMutex(this->mixer_lock);
+                this->hidden->bufferOffset = 0;
+            }
+
+            len = this->hidden->bufferSize - this->hidden->bufferOffset;
+            if (len > remaining)
+                len = remaining;
+            SDL_memcpy(ptr, (char *)this->hidden->buffer +
+                       this->hidden->bufferOffset, len);
+            ptr = (char *)ptr + len;
+            remaining -= len;
+            this->hidden->bufferOffset += len;
+        }
+    }
+
+    return 0;
+}
+
+static OSStatus
+inputCallback(void *inRefCon,
+              AudioUnitRenderActionFlags * ioActionFlags,
+              const AudioTimeStamp * inTimeStamp,
+              UInt32 inBusNumber, UInt32 inNumberFrames,
+              AudioBufferList * ioData)
+{
+    /* err = AudioUnitRender(afr->fAudioUnit, ioActionFlags, inTimeStamp, inBusNumber, inNumberFrames, afr->fAudioBuffer); */
+    /* !!! FIXME: write me! */
+    return noErr;
+}
+#endif
+
 
 #if MACOSX_COREAUDIO
 static const AudioObjectPropertyAddress alive_address =
@@ -528,6 +702,7 @@
 static void
 COREAUDIO_CloseDevice(_THIS)
 {
+#if defined(MAC_OS_X_VERSION_10_5)
     const SDL_bool iscapture = this->iscapture;
 
 /* !!! FIXME: what does iOS do when a bluetooth audio device vanishes? Headphones unplugged? */
@@ -565,6 +740,43 @@
     } else {
         open_playback_devices--;
     }
+#else
+    if (this->hidden != NULL) {
+        if (this->hidden->audioUnitOpened) {
+            OSStatus result = noErr;
+            AURenderCallbackStruct callback;
+            const AudioUnitElement output_bus = 0;
+            const AudioUnitElement input_bus = 1;
+            const int iscapture = this->iscapture;
+            const AudioUnitElement bus =
+                ((iscapture) ? input_bus : output_bus);
+            const AudioUnitScope scope =
+                ((iscapture) ? kAudioUnitScope_Output :
+                 kAudioUnitScope_Input);
+
+            /* stop processing the audio unit */
+            result = AudioOutputUnitStop(this->hidden->audioUnit);
+
+            /* Remove the input callback */
+            SDL_memset(&callback, 0, sizeof(AURenderCallbackStruct));
+            result = AudioUnitSetProperty(this->hidden->audioUnit,
+                                          kAudioUnitProperty_SetRenderCallback,
+                                          scope, bus, &callback,
+                                          sizeof(callback));
+
+            #if MACOSX_COREAUDIO
+            CloseComponent(this->hidden->audioUnit);
+            #else
+            AudioComponentInstanceDispose(this->hidden->audioUnit);
+            #endif
+
+            this->hidden->audioUnitOpened = 0;
+        }
+        SDL_free(this->hidden->buffer);
+        SDL_free(this->hidden);
+        this->hidden = NULL;
+    }
+#endif
 }
 
 #if MACOSX_COREAUDIO
@@ -620,8 +832,113 @@
     this->hidden->deviceID = devid;
     return 1;
 }
+
+#if !defined(MAC_OS_X_VERSION_10_5)
+static int
+prepare_audiounit(_THIS, const char *devname, int iscapture,
+                  const AudioStreamBasicDescription * strdesc)
+{
+    OSStatus result = noErr;
+    AURenderCallbackStruct callback;
+#if MACOSX_COREAUDIO
+    ComponentDescription desc;
+    Component comp = NULL;
+#else
+    AudioComponentDescription desc;
+    AudioComponent comp = NULL;
+#endif
+    const AudioUnitElement output_bus = 0;
+    const AudioUnitElement input_bus = 1;
+    const AudioUnitElement bus = ((iscapture) ? input_bus : output_bus);
+    const AudioUnitScope scope = ((iscapture) ? kAudioUnitScope_Output :
+                                  kAudioUnitScope_Input);
+
+#if MACOSX_COREAUDIO
+    if (!find_device_by_name(this, devname, iscapture)) {
+        SDL_SetError("Couldn't find requested CoreAudio device");
+        return 0;
+    }
+#endif
+
+    SDL_zero(desc);
+    desc.componentType = kAudioUnitType_Output;
+    desc.componentManufacturer = kAudioUnitManufacturer_Apple;
+
+#if MACOSX_COREAUDIO
+    desc.componentSubType = kAudioUnitSubType_DefaultOutput;
+    comp = FindNextComponent(NULL, &desc);
+#else
+    desc.componentSubType = kAudioUnitSubType_RemoteIO;
+    comp = AudioComponentFindNext(NULL, &desc);
+#endif
+
+    if (comp == NULL) {
+        SDL_SetError("Couldn't find requested CoreAudio component");
+        return 0;
+    }
+
+    /* Open & initialize the audio unit */
+#if MACOSX_COREAUDIO
+    result = OpenAComponent(comp, &this->hidden->audioUnit);
+    CHECK_RESULT("OpenAComponent");
+#else
+    /*
+       AudioComponentInstanceNew only available on iPhone OS 2.0 and Mac OS X 10.6
+       We can't use OpenAComponent on iPhone because it is not present
+     */
+    result = AudioComponentInstanceNew(comp, &this->hidden->audioUnit);
+    CHECK_RESULT("AudioComponentInstanceNew");
+#endif
+
+    this->hidden->audioUnitOpened = 1;
+
+#if MACOSX_COREAUDIO
+    result = AudioUnitSetProperty(this->hidden->audioUnit,
+                                  kAudioOutputUnitProperty_CurrentDevice,
+                                  kAudioUnitScope_Global, 0,
+                                  &this->hidden->deviceID,
+                                  sizeof(AudioDeviceID));
+    CHECK_RESULT
+        ("AudioUnitSetProperty (kAudioOutputUnitProperty_CurrentDevice)");
+#endif
+
+    /* Set the data format of the audio unit. */
+    result = AudioUnitSetProperty(this->hidden->audioUnit,
+                                  kAudioUnitProperty_StreamFormat,
+                                  scope, bus, strdesc, sizeof(*strdesc));
+    CHECK_RESULT("AudioUnitSetProperty (kAudioUnitProperty_StreamFormat)");
+
+    /* Set the audio callback */
+    SDL_memset(&callback, 0, sizeof(AURenderCallbackStruct));
+    callback.inputProc = ((iscapture) ? inputCallback : outputCallback);
+    callback.inputProcRefCon = this;
+    result = AudioUnitSetProperty(this->hidden->audioUnit,
+                                  kAudioUnitProperty_SetRenderCallback,
+                                  scope, bus, &callback, sizeof(callback));
+    CHECK_RESULT
+        ("AudioUnitSetProperty (kAudioUnitProperty_SetRenderCallback)");
+
+    /* Calculate the final parameters for this audio specification */
+    SDL_CalculateAudioSpec(&this->spec);
+
+    /* Allocate a sample buffer */
+    this->hidden->bufferOffset = this->hidden->bufferSize = this->spec.size;
+    this->hidden->buffer = SDL_malloc(this->hidden->bufferSize);
+
+    result = AudioUnitInitialize(this->hidden->audioUnit);
+    CHECK_RESULT("AudioUnitInitialize");
+
+    /* Finally, start processing of the audio unit */
+    result = AudioOutputUnitStart(this->hidden->audioUnit);
+    CHECK_RESULT("AudioOutputUnitStart");
+
+    /* We're running! */
+    return 1;
+}
+#endif
 #endif
 
+#if defined(MAC_OS_X_VERSION_10_5)
 static int
 prepare_audioqueue(_THIS)
 {
@@ -741,6 +1058,7 @@
 
     return 0;
 }
+#endif
 
 static int
 COREAUDIO_OpenDevice(_THIS, void *handle, const char *devname, int iscapture)
@@ -820,6 +1138,7 @@
     strdesc->mBytesPerFrame = strdesc->mBitsPerChannel * strdesc->mChannelsPerFrame / 8;
     strdesc->mBytesPerPacket = strdesc->mBytesPerFrame * strdesc->mFramesPerPacket;
 
+#if defined(MAC_OS_X_VERSION_10_5)
 #if MACOSX_COREAUDIO
     if (!prepare_device(this, handle, iscapture)) {
         return -1;
@@ -848,6 +1167,14 @@
     }
 
     return (this->hidden->thread != NULL) ? 0 : -1;
+#else
+    if (!prepare_audiounit(this, devname, iscapture, strdesc)) {
+        COREAUDIO_CloseDevice(this);
+        return -1;      /* prepare_audiounit() will call SDL_SetError()... */
+    }
+
+    return 0;   /* good to go. */
+#endif
 }
 
 static void
@@ -870,14 +1197,18 @@
 
 #if MACOSX_COREAUDIO
     impl->DetectDevices = COREAUDIO_DetectDevices;
+#if defined(MAC_OS_X_VERSION_10_5)
     AudioObjectAddPropertyListener(kAudioObjectSystemObject, &devlist_address, device_list_changed, NULL);
+#endif
 #else
     impl->OnlyHasDefaultOutputDevice = 1;
     impl->OnlyHasDefaultCaptureDevice = 1;
 #endif
 
     impl->ProvidesOwnCallbackThread = 1;
+#if defined(MAC_OS_X_VERSION_10_5)
     impl->HasCaptureSupport = 1;
+#endif
 
     return 1;   /* this audio target is available. */
 }
diff -ru SDL2-2.0.6-orig/src/file/cocoa/SDL_rwopsbundlesupport.m SDL2-2.0.6-tiger/src/file/cocoa/SDL_rwopsbundlesupport.m
--- SDL2-2.0.6-orig/src/file/cocoa/SDL_rwopsbundlesupport.m	2017-09-22 20:51:01.000000000 +0200
+++ SDL2-2.0.6-tiger/src/file/cocoa/SDL_rwopsbundlesupport.m	2018-05-25 16:12:54.000000000 +0200
@@ -21,6 +21,14 @@
 #include "../../SDL_internal.h"
 
 #ifdef __APPLE__
+
+#if defined(__ALTIVEC__) && !defined(MAC_OS_X_VERSION_10_5)
+/* to cricumvent a bug in Mac OS X 10.4 SDK */
+#define vector __vector
+#include <CoreServices/CoreServices.h>
+#undef vector
+#endif
+
 #import <Foundation/Foundation.h>
 
 #include "SDL_rwopsbundlesupport.h"
@@ -33,7 +41,9 @@
  Also, note the bundle layouts are different for iPhone and Mac.
 */
 FILE* SDL_OpenFPFromBundleOrFallback(const char *file, const char *mode)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
+#endif
 {
     FILE* fp = NULL;
 
@@ -42,6 +52,9 @@
         return fopen(file, mode);
     }
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    NSAutoreleasePool* autorelease_pool = [[NSAutoreleasePool alloc] init];
+#endif
     NSFileManager* file_manager = [NSFileManager defaultManager];
     NSString* resource_path = [[NSBundle mainBundle] resourcePath];
 
@@ -54,8 +67,15 @@
         fp = fopen(file, mode);
     }
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    [autorelease_pool drain];
+#endif
     return fp;
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+}
+#else
 }}
+#endif
 
 #endif /* __APPLE__ */
 
diff -ru SDL2-2.0.6-orig/src/filesystem/cocoa/SDL_sysfilesystem.m SDL2-2.0.6-tiger/src/filesystem/cocoa/SDL_sysfilesystem.m
--- SDL2-2.0.6-orig/src/filesystem/cocoa/SDL_sysfilesystem.m	2017-09-22 20:51:01.000000000 +0200
+++ SDL2-2.0.6-tiger/src/filesystem/cocoa/SDL_sysfilesystem.m	2018-05-25 16:11:47.000000000 +0200
@@ -25,6 +25,13 @@
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
 /* System dependent filesystem routines                                */
 
+#if defined(__ALTIVEC__) && !defined(MAC_OS_X_VERSION_10_5)
+/* to cricumvent a bug in Mac OS X 10.4 SDK */
+#define vector __vector
+#include <CoreServices/CoreServices.h>
+#undef vector
+#endif
+
 #include <Foundation/Foundation.h>
 #include <sys/stat.h>
 #include <sys/types.h>
@@ -35,8 +42,13 @@
 
 char *
 SDL_GetBasePath(void)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     NSBundle *bundle = [NSBundle mainBundle];
     const char* baseType = [[[bundle infoDictionary] objectForKey:@"SDL_FILESYSTEM_BASE_DIR_TYPE"] UTF8String];
     const char *base = NULL;
@@ -64,13 +76,24 @@
         }
     }
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
     return retval;
 }}
+#else
+    [pool release];
+    return retval;
+}
+#endif
 
 char *
 SDL_GetPrefPath(const char *org, const char *app)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     if (!app) {
         SDL_InvalidParamError("app");
         return NULL;
@@ -109,8 +132,14 @@
         }
     }
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
     return retval;
 }}
+#else
+    [pool release];
+    return retval;
+}
+#endif
 
 #endif /* SDL_FILESYSTEM_COCOA */
 
diff -ru SDL2-2.0.6-orig/src/joystick/darwin/SDL_sysjoystick.c SDL2-2.0.6-tiger/src/joystick/darwin/SDL_sysjoystick.c
--- SDL2-2.0.6-orig/src/joystick/darwin/SDL_sysjoystick.c	2017-09-22 20:51:01.000000000 +0200
+++ SDL2-2.0.6-tiger/src/joystick/darwin/SDL_sysjoystick.c	2018-05-24 21:19:36.000000000 +0200
@@ -459,7 +459,11 @@
     device->instance_id = ++s_joystick_instance_id;
 
     /* We have to do some storage of the io_service_t for SDL_HapticOpenFromJoystick */
+    #if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
     ioservice = IOHIDDeviceGetService(ioHIDDeviceObject);
+    #else
+    ioservice = 0;
+    #endif
 #if SDL_HAPTIC_IOKIT
     if ((ioservice) && (FFIsForceFeedback(ioservice) == FF_OK)) {
         device->ffservice = ioservice;
diff -ru SDL2-2.0.6-orig/src/video/cocoa/SDL_cocoaclipboard.m SDL2-2.0.6-tiger/src/video/cocoa/SDL_cocoaclipboard.m
--- SDL2-2.0.6-orig/src/video/cocoa/SDL_cocoaclipboard.m	2017-09-22 20:51:01.000000000 +0200
+++ SDL2-2.0.6-tiger/src/video/cocoa/SDL_cocoaclipboard.m	2018-05-24 21:19:36.000000000 +0200
@@ -25,27 +25,64 @@
 #include "SDL_cocoavideo.h"
 #include "../../events/SDL_clipboardevents_c.h"
 
+static NSString *
+GetTextFormat(_THIS)
+{
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
+    if (floor(NSAppKitVersionNumber) > NSAppKitVersionNumber10_5) {
+        return NSPasteboardTypeString;
+    } else {
+#endif
+        return NSStringPboardType;
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
+    }
+#endif
+}
+
 int
 Cocoa_SetClipboardText(_THIS, const char *text)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{   NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
+#endif
     SDL_VideoData *data = (SDL_VideoData *) _this->driverdata;
     NSPasteboard *pasteboard;
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
     NSString *format = NSPasteboardTypeString;
+#else
+    NSString *format = GetTextFormat(_this);
+#endif
 
     pasteboard = [NSPasteboard generalPasteboard];
     data->clipboard_count = [pasteboard declareTypes:[NSArray arrayWithObject:format] owner:nil];
     [pasteboard setString:[NSString stringWithUTF8String:text] forType:format];
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    [pool release];
+#endif
     return 0;
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+}
+#endif
 
 char *
 Cocoa_GetClipboardText(_THIS)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{   NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
+#endif
     NSPasteboard *pasteboard;
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
     NSString *format = NSPasteboardTypeString;
+#else
+    NSString *format = GetTextFormat(_this);
+#endif
     NSString *available;
     char *text;
 
@@ -66,8 +103,15 @@
         text = SDL_strdup("");
     }
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    [pool release];
+#endif
     return text;
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+}
+#endif
 
 SDL_bool
 Cocoa_HasClipboardText(_THIS)
@@ -83,8 +127,12 @@
 
 void
 Cocoa_CheckClipboardUpdate(struct SDL_VideoData * data)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{   NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
+#endif
     NSPasteboard *pasteboard;
     NSInteger count;
 
@@ -96,7 +144,12 @@
         }
         data->clipboard_count = count;
     }
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+    [pool release];
+}
+#endif
 
 #endif /* SDL_VIDEO_DRIVER_COCOA */
 
diff -ru SDL2-2.0.6-orig/src/video/cocoa/SDL_cocoaevents.m SDL2-2.0.6-tiger/src/video/cocoa/SDL_cocoaevents.m
--- SDL2-2.0.6-orig/src/video/cocoa/SDL_cocoaevents.m	2017-09-22 20:51:01.000000000 +0200
+++ SDL2-2.0.6-tiger/src/video/cocoa/SDL_cocoaevents.m	2018-05-25 22:24:46.000000000 +0200
@@ -55,6 +55,19 @@
     SDL_VideoDevice *_this = SDL_GetVideoDevice();
 
     switch ([theEvent type]) {
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+        case NSLeftMouseDown:
+        case NSOtherMouseDown:
+        case NSRightMouseDown:
+        case NSLeftMouseUp:
+        case NSOtherMouseUp:
+        case NSRightMouseUp:
+        case NSLeftMouseDragged:
+        case NSRightMouseDragged:
+        case NSOtherMouseDragged: /* usually middle mouse dragged */
+        case NSMouseMoved:
+        case NSScrollWheel:
+#else
         case NSEventTypeLeftMouseDown:
         case NSEventTypeOtherMouseDown:
         case NSEventTypeRightMouseDown:
@@ -66,11 +79,18 @@
         case NSEventTypeOtherMouseDragged: /* usually middle mouse dragged */
         case NSEventTypeMouseMoved:
         case NSEventTypeScrollWheel:
+#endif
             Cocoa_HandleMouseEvent(_this, theEvent);
             break;
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+        case NSKeyDown:
+        case NSKeyUp:
+        case NSFlagsChanged:
+#else
         case NSEventTypeKeyDown:
         case NSEventTypeKeyUp:
         case NSEventTypeFlagsChanged:
+#endif
             Cocoa_HandleKeyEvent(_this, theEvent);
             break;
         default:
@@ -97,7 +117,11 @@
 - (void)setAppleMenu:(NSMenu *)menu;
 @end
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
 @interface SDLAppDelegate : NSObject <NSApplicationDelegate> {
+#else
+@interface SDLAppDelegate : NSObject {
+#endif
 @public
     BOOL seenFirstActivate;
 }
@@ -141,6 +165,9 @@
 - (void)windowWillClose:(NSNotification *)notification;
 {
     NSWindow *win = (NSWindow*)[notification object];
+#if !defined(MAC_OS_X_VERSION_10_5)
+    int i;
+#endif
 
     if (![win isKeyWindow]) {
         return;
@@ -155,10 +182,18 @@
      * want to try its list first since the behavior in other apps is to only
      * make the 'About' window key if no other windows are on-screen.
      */
+#if defined(MAC_OS_X_VERSION_10_5)
     for (NSWindow *window in [NSApp orderedWindows]) {
+#else
+    /* old way to iterate */
+    for (i = 0; i < [[NSApp orderedWindows] count]; i++) {
+        NSWindow *window = [[NSApp orderedWindows] objectAtIndex:i];
+#endif
         if (window != win && [window canBecomeKeyWindow]) {
-            if (![window isOnActiveSpace]) {
-                continue;
+            if ([window respondsToSelector:@selector(isOnActiveSpace)]) {
+                if (![window isOnActiveSpace]) {
+                    continue;
+                }
             }
             [window makeKeyAndOrderFront:self];
             return;
@@ -169,17 +204,29 @@
      * the active Space in z-order (including the 'About' window, if it's shown)
      * and make the first one key.
      */
+    if ([NSWindow respondsToSelector:@selector(windowNumbersWithOptions:)]) {
+#if defined(MAC_OS_X_VERSION_10_5)
     for (NSNumber *num in [NSWindow windowNumbersWithOptions:0]) {
+#else
+    /* old way to iterate */
+    for (i = 0; i < [[NSWindow windowNumbersWithOptions:0] count]; i++) {
+        NSNumber *num = [[NSWindow windowNumbersWithOptions:0] objectAtIndex:i];
+#endif
+        if([num respondsToSelector:@selector(integerValue)]) {
         NSWindow *window = [NSApp windowWithWindowNumber:[num integerValue]];
         if (window && window != win && [window canBecomeKeyWindow]) {
             [window makeKeyAndOrderFront:self];
             return;
         }
+        }
+    }
     }
 }
 
 - (void)focusSomeWindow:(NSNotification *)aNotification
 {
+    SDL_VideoDevice *device;
+
     /* HACK: Ignore the first call. The application gets a
      * applicationDidBecomeActive: a little bit after the first window is
      * created, and if we don't ignore it, a window that has been created with
@@ -190,7 +237,7 @@
         return;
     }
 
-    SDL_VideoDevice *device = SDL_GetVideoDevice();
+    device = SDL_GetVideoDevice();
     if (device && device->windows) {
         SDL_Window *window = device->windows;
         int i;
@@ -328,6 +375,7 @@
     [windowMenu release];
 
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
     /* Add the fullscreen view toggle menu option, if supported */
     if (floor(NSAppKitVersionNumber) > NSAppKitVersionNumber10_6) {
         /* Create the view menu */
@@ -345,22 +393,39 @@
 
         [viewMenu release];
     }
+#endif
 }
 
 void
 Cocoa_RegisterApp(void)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     /* This can get called more than once! Be careful what you initialize! */
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1060
+    ProcessSerialNumber psn;
+
+    if (!GetCurrentProcess(&psn)) {
+        TransformProcessType(&psn, kProcessTransformToForegroundApplication);
+        SetFrontProcess(&psn);
+    }
+#endif
 
     if (NSApp == nil) {
+        NSDictionary *appDefaults;
         [SDLApplication sharedApplication];
         SDL_assert(NSApp != nil);
 
         s_bShouldHandleEventsInSDLApplication = SDL_TRUE;
 
         if (!SDL_GetHintBoolean(SDL_HINT_MAC_BACKGROUND_APP, SDL_FALSE)) {
+#if defined(MAC_OS_X_VERSION_10_6)
             [NSApp setActivationPolicy:NSApplicationActivationPolicyRegular];
+#endif
             [NSApp activateIgnoringOtherApps:YES];
 		}
 		
@@ -368,7 +433,7 @@
             CreateApplicationMenus();
         }
         [NSApp finishLaunching];
-        NSDictionary *appDefaults = [[NSDictionary alloc] initWithObjectsAndKeys:
+        appDefaults = [[NSDictionary alloc] initWithObjectsAndKeys:
             [NSNumber numberWithBool:NO], @"AppleMomentumScrollSupported",
             [NSNumber numberWithBool:NO], @"ApplePressAndHoldEnabled",
             [NSNumber numberWithBool:YES], @"ApplePersistenceIgnoreState",
@@ -388,12 +453,22 @@
             appDelegate->seenFirstActivate = YES;
         }
     }
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+    [pool release];
+}
+#endif
 
 void
 Cocoa_PumpEvents(_THIS)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool;
+#endif
 #if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
     /* Update activity every 30 seconds to prevent screensaver */
     SDL_VideoData *data = (SDL_VideoData *)_this->driverdata;
@@ -407,8 +482,15 @@
     }
 #endif
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    pool = [[NSAutoreleasePool alloc] init];
+#endif
     for ( ; ; ) {
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+        NSEvent *event = [NSApp nextEventMatchingMask:NSAnyEventMask untilDate:[NSDate distantPast] inMode:NSDefaultRunLoopMode dequeue:YES ];
+#else
         NSEvent *event = [NSApp nextEventMatchingMask:NSEventMaskAny untilDate:[NSDate distantPast] inMode:NSDefaultRunLoopMode dequeue:YES ];
+#endif
         if ( event == nil ) {
             break;
         }
@@ -420,10 +502,16 @@
         // Pass events down to SDLApplication to be handled in sendEvent:
         [NSApp sendEvent:event];
     }
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+    [pool release];
+}
+#endif
 
 void
 Cocoa_SuspendScreenSaver(_THIS)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
     SDL_VideoData *data = (SDL_VideoData *)_this->driverdata;
@@ -450,6 +538,10 @@
                                            &data->screensaver_assertion);
     }
 }}
+#else
+{
+}
+#endif
 
 #endif /* SDL_VIDEO_DRIVER_COCOA */
 
diff -ru SDL2-2.0.6-orig/src/video/cocoa/SDL_cocoakeyboard.m SDL2-2.0.6-tiger/src/video/cocoa/SDL_cocoakeyboard.m
--- SDL2-2.0.6-orig/src/video/cocoa/SDL_cocoakeyboard.m	2017-09-22 20:51:01.000000000 +0200
+++ SDL2-2.0.6-tiger/src/video/cocoa/SDL_cocoakeyboard.m	2018-05-24 22:24:10.000000000 +0200
@@ -34,7 +34,11 @@
 /*#define DEBUG_IME NSLog */
 #define DEBUG_IME(...)
 
+#if defined(MAC_OS_X_VERSION_10_5)
 @interface SDLTranslatorResponder : NSView <NSTextInputClient> {
+#else
+@interface SDLTranslatorResponder : NSView {
+#endif
     NSString *_markedText;
     NSRange   _markedRange;
     NSRange   _selectedRange;
@@ -93,6 +97,14 @@
     return _selectedRange;
 }
 
+- (void)unmarkText
+{
+    [_markedText release];
+    _markedText = nil;
+
+    SDL_SendEditingText("", 0, 0);
+}
+
 - (void)setMarkedText:(id)aString selectedRange:(NSRange)selectedRange replacementRange:(NSRange)replacementRange;
 {
     if ([aString isKindOfClass:[NSAttributedString class]]) {
@@ -119,14 +131,6 @@
           selRange.location, selRange.length);
 }
 
-- (void)unmarkText
-{
-    [_markedText release];
-    _markedText = nil;
-
-    SDL_SendEditingText("", 0, 0);
-}
-
 - (NSRect)firstRectForCharacterRange:(NSRange)aRange actualRange:(NSRangePointer)actualRange;
 {
     NSWindow *window = [self window];
@@ -144,12 +148,18 @@
             NSStringFromRect(rect));
 
 #if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+#if defined(MAC_OS_X_VERSION_10_7)
     if (![window respondsToSelector:@selector(convertRectToScreen:)]) {
+#endif
         rect.origin = [window convertBaseToScreen:rect.origin];
+#if defined(MAC_OS_X_VERSION_10_7)
     } else
 #endif
+#endif
     {
+#if defined(MAC_OS_X_VERSION_10_7)
         rect = [window convertRectToScreen:rect];
+#endif
     }
 
     return rect;
@@ -193,6 +203,7 @@
 http://stackoverflow.com/questions/7190852/using-iohidmanager-to-get-modifier-key-events
 */
 
+#if defined(MAC_OS_X_VERSION_10_5)
 static IOHIDManagerRef s_hidManager = NULL;
 
 static void
@@ -296,6 +307,7 @@
         CFRelease(keyboard);
     }
 }
+#endif
 
 /* This is a helper function for HandleModifierSide. This
  * function reverts back to behavior before the distinction between
@@ -504,6 +516,7 @@
 static void
 UpdateKeymap(SDL_VideoData *data, SDL_bool send_event)
 {
+#if defined(MAC_OS_X_VERSION_10_5)
     TISInputSourceRef key_layout;
     const void *chr_data;
     int i;
@@ -566,6 +579,7 @@
 
 cleanup:
     CFRelease(key_layout);
+#endif
 }
 
 void
@@ -583,24 +597,36 @@
     SDL_SetScancodeName(SDL_SCANCODE_RALT, "Right Option");
     SDL_SetScancodeName(SDL_SCANCODE_RGUI, "Right Command");
 
+    if([NSEvent respondsToSelector:@selector(modifierFlags)]) {
     data->modifierFlags = [NSEvent modifierFlags];
+    } else {
+    data->modifierFlags = 0;
+    }
     SDL_ToggleModState(KMOD_CAPS, (data->modifierFlags & NSEventModifierFlagCapsLock) != 0);
 
+#if defined(MAC_OS_X_VERSION_10_5)
     InitHIDCallback();
+#endif
 }
 
 void
 Cocoa_StartTextInput(_THIS)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     SDL_VideoData *data = (SDL_VideoData *) _this->driverdata;
     SDL_Window *window = SDL_GetKeyboardFocus();
     NSWindow *nswindow = nil;
+    NSView *parentView;
     if (window) {
         nswindow = ((SDL_WindowData*)window->driverdata)->nswindow;
     }
 
-    NSView *parentView = [nswindow contentView];
+    parentView = [nswindow contentView];
 
     /* We only keep one field editor per process, since only the front most
      * window can receive text input events, so it make no sense to keep more
@@ -618,20 +644,37 @@
         [parentView addSubview: data->fieldEdit];
         [nswindow makeFirstResponder: data->fieldEdit];
     }
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+    [pool release];
+}
+#endif
 
 void
 Cocoa_StopTextInput(_THIS)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
+#endif
 {
     SDL_VideoData *data = (SDL_VideoData *) _this->driverdata;
 
     if (data && data->fieldEdit) {
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+        NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
         [data->fieldEdit removeFromSuperview];
         [data->fieldEdit release];
         data->fieldEdit = nil;
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+        [pool release];
+#endif
     }
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+}
+#endif
 
 void
 Cocoa_SetTextInputRect(_THIS, SDL_Rect *rect)
@@ -649,16 +692,17 @@
 void
 Cocoa_HandleKeyEvent(_THIS, NSEvent *event)
 {
+    unsigned short scancode;
+    SDL_Scancode code;
+#if 0
+    const char *text;
+#endif
     SDL_VideoData *data = _this ? ((SDL_VideoData *) _this->driverdata) : NULL;
     if (!data) {
         return;  /* can happen when returning from fullscreen Space on shutdown */
     }
 
-    unsigned short scancode = [event keyCode];
-    SDL_Scancode code;
-#if 0
-    const char *text;
-#endif
+    scancode = [event keyCode];
 
     if ((scancode == 10 || scancode == 50) && KBGetLayoutType(LMGetKbdType()) == kKeyboardISO) {
         /* see comments in SDL_cocoakeys.h */
@@ -673,7 +717,11 @@
     }
 
     switch ([event type]) {
+#if !defined(MAC_OS_X_VERSION_10_12)
+    case NSKeyDown:
+#else
     case NSEventTypeKeyDown:
+#endif
         if (![event isARepeat]) {
             /* See if we need to rebuild the keyboard layout */
             UpdateKeymap(data, SDL_TRUE);
@@ -697,10 +745,18 @@
 #endif
         }
         break;
+#if !defined(MAC_OS_X_VERSION_10_12)
+    case NSKeyUp:
+#else
     case NSEventTypeKeyUp:
+#endif
         SDL_SendKeyboardKey(SDL_RELEASED, code);
         break;
+#if !defined(MAC_OS_X_VERSION_10_12)
+    case NSFlagsChanged:
+#else
     case NSEventTypeFlagsChanged:
+#endif
         /* FIXME CW 2007-08-14: check if this whole mess that takes up half of this file is really necessary */
         HandleModifiers(_this, scancode, [event modifierFlags]);
         break;
@@ -712,7 +768,9 @@
 void
 Cocoa_QuitKeyboard(_THIS)
 {
+#if defined(MAC_OS_X_VERSION_10_5)
     QuitHIDCallback();
+#endif
 }
 
 #endif /* SDL_VIDEO_DRIVER_COCOA */
diff -ru SDL2-2.0.6-orig/src/video/cocoa/SDL_cocoamessagebox.m SDL2-2.0.6-tiger/src/video/cocoa/SDL_cocoamessagebox.m
--- SDL2-2.0.6-orig/src/video/cocoa/SDL_cocoamessagebox.m	2017-09-22 20:51:01.000000000 +0200
+++ SDL2-2.0.6-tiger/src/video/cocoa/SDL_cocoamessagebox.m	2018-05-24 21:19:36.000000000 +0200
@@ -92,10 +92,15 @@
 /* Display a Cocoa message box */
 int
 Cocoa_ShowMessageBox(const SDL_MessageBoxData *messageboxdata, int *buttonid)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
+#endif
 {
     Cocoa_RegisterApp();
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     NSAlert* alert = [[[NSAlert alloc] init] autorelease];
 
     if (messageboxdata->flags & SDL_MESSAGEBOX_ERROR) {
@@ -137,8 +142,15 @@
         returnValue = SDL_SetError("Did not get a valid `clicked button' id: %ld", (long)clicked);
     }
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    [pool release];
+#endif
     return returnValue;
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+}
+#endif
 
 #endif /* SDL_VIDEO_DRIVER_COCOA */
 
diff -ru SDL2-2.0.6-orig/src/video/cocoa/SDL_cocoametalview.h SDL2-2.0.6-tiger/src/video/cocoa/SDL_cocoametalview.h
--- SDL2-2.0.6-orig/src/video/cocoa/SDL_cocoametalview.h	2017-09-22 20:51:01.000000000 +0200
+++ SDL2-2.0.6-tiger/src/video/cocoa/SDL_cocoametalview.h	2018-05-24 22:26:45.000000000 +0200
@@ -29,8 +29,8 @@
 #ifndef SDL_cocoametalview_h_
 #define SDL_cocoametalview_h_
 
-#import "../SDL_sysvideo.h"
-#import "SDL_cocoawindow.h"
+#include "../SDL_sysvideo.h"
+#include "SDL_cocoawindow.h"
 
 #if SDL_VIDEO_VULKAN && SDL_VIDEO_DRIVER_COCOA
 
diff -ru SDL2-2.0.6-orig/src/video/cocoa/SDL_cocoametalview.m SDL2-2.0.6-tiger/src/video/cocoa/SDL_cocoametalview.m
--- SDL2-2.0.6-orig/src/video/cocoa/SDL_cocoametalview.m	2017-09-22 20:51:01.000000000 +0200
+++ SDL2-2.0.6-tiger/src/video/cocoa/SDL_cocoametalview.m	2018-05-24 22:25:57.000000000 +0200
@@ -26,7 +26,7 @@
  * how to add a CAMetalLayer backed view.
  */
 
-#import "SDL_cocoametalview.h"
+#include "SDL_cocoametalview.h"
 
 #if SDL_VIDEO_VULKAN && SDL_VIDEO_DRIVER_COCOA
 
diff -ru SDL2-2.0.6-orig/src/video/cocoa/SDL_cocoamodes.h SDL2-2.0.6-tiger/src/video/cocoa/SDL_cocoamodes.h
--- SDL2-2.0.6-orig/src/video/cocoa/SDL_cocoamodes.h	2017-09-22 20:51:01.000000000 +0200
+++ SDL2-2.0.6-tiger/src/video/cocoa/SDL_cocoamodes.h	2018-05-24 21:19:36.000000000 +0200
@@ -30,7 +30,11 @@
 
 typedef struct
 {
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
     CGDisplayModeRef moderef;
+#else
+    const void *moderef;
+#endif
 } SDL_DisplayModeData;
 
 extern void Cocoa_InitModes(_THIS);
diff -ru SDL2-2.0.6-orig/src/video/cocoa/SDL_cocoamodes.m SDL2-2.0.6-tiger/src/video/cocoa/SDL_cocoamodes.m
--- SDL2-2.0.6-orig/src/video/cocoa/SDL_cocoamodes.m	2017-09-22 20:51:01.000000000 +0200
+++ SDL2-2.0.6-tiger/src/video/cocoa/SDL_cocoamodes.m	2018-05-24 22:37:32.000000000 +0200
@@ -100,14 +100,25 @@
 }
 
 static SDL_bool
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
 GetDisplayMode(_THIS, CGDisplayModeRef vidmode, CFArrayRef modelist, CVDisplayLinkRef link, SDL_DisplayMode *mode)
+#else
+GetDisplayMode(_THIS, const void *moderef, CFArrayRef modelist, CVDisplayLinkRef link, SDL_DisplayMode *mode)
+#endif
 {
     SDL_DisplayModeData *data;
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
     int width = (int) CGDisplayModeGetWidth(vidmode);
     int height = (int) CGDisplayModeGetHeight(vidmode);
     int bpp = 0;
     int refreshRate = 0;
     CFStringRef fmt;
+#else
+    long width = 0;
+    long height = 0;
+    long bpp = 0;
+    long refreshRate = 0;
+#endif
 
     /* Ignore this mode if it's low-dpi (@1x) and we have a high-dpi mode in the
      * list with the same size in points.
@@ -145,8 +156,13 @@
     if (!data) {
         return SDL_FALSE;
     }
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
     data->moderef = vidmode;
+#else
+    data->moderef = moderef;
+#endif
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
     fmt = CGDisplayModeCopyPixelEncoding(vidmode);
     refreshRate = (int) (CGDisplayModeGetRefreshRate(vidmode) + 0.5);
 
@@ -164,6 +180,22 @@
     }
 
     CFRelease(fmt);
+#else
+    {
+        CFNumberRef number;
+        double refresh;
+        CFDictionaryRef vidmode = (CFDictionaryRef) moderef;
+        number = CFDictionaryGetValue(vidmode, kCGDisplayWidth);
+        CFNumberGetValue(number, kCFNumberLongType, &width);
+        number = CFDictionaryGetValue(vidmode, kCGDisplayHeight);
+        CFNumberGetValue(number, kCFNumberLongType, &height);
+        number = CFDictionaryGetValue(vidmode, kCGDisplayBitsPerPixel);
+        CFNumberGetValue(number, kCFNumberLongType, &bpp);
+        number = CFDictionaryGetValue(vidmode, kCGDisplayRefreshRate);
+        CFNumberGetValue(number, kCFNumberDoubleType, &refresh);
+        refreshRate = (long) (refresh + 0.5);
+    }
+#endif
 
     /* CGDisplayModeGetRefreshRate returns 0 for many non-CRT displays. */
     if (refreshRate == 0 && link != NULL) {
@@ -212,8 +244,13 @@
 
 void
 Cocoa_InitModes(_THIS)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     CGDisplayErr result;
     CGDirectDisplayID *displays;
     CGDisplayCount numDisplays;
@@ -222,6 +259,9 @@
     result = CGGetOnlineDisplayList(0, NULL, &numDisplays);
     if (result != kCGErrorSuccess) {
         CG_SetError("CGGetOnlineDisplayList()", result);
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+        [pool release];
+#endif
         return;
     }
     displays = SDL_stack_alloc(CGDirectDisplayID, numDisplays);
@@ -229,6 +269,9 @@
     if (result != kCGErrorSuccess) {
         CG_SetError("CGGetOnlineDisplayList()", result);
         SDL_stack_free(displays);
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+        [pool release];
+#endif
         return;
     }
 
@@ -238,7 +281,11 @@
             SDL_VideoDisplay display;
             SDL_DisplayData *displaydata;
             SDL_DisplayMode mode;
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
             CGDisplayModeRef moderef = NULL;
+#else
+            const void *moderef = NULL;
+#endif
             CVDisplayLinkRef link = NULL;
 
             if (pass == 0) {
@@ -255,7 +302,11 @@
                 continue;
             }
 
+            #if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
             moderef = CGDisplayCopyDisplayMode(displays[i]);
+            #else
+            moderef = CGDisplayCurrentMode(displays[i]);
+            #endif
 
             if (!moderef) {
                 continue;
@@ -263,7 +314,9 @@
 
             displaydata = (SDL_DisplayData *) SDL_malloc(sizeof(*displaydata));
             if (!displaydata) {
+            #if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
                 CGDisplayModeRelease(moderef);
+            #endif
                 continue;
             }
             displaydata->display = displays[i];
@@ -275,7 +328,9 @@
             display.name = (char *)Cocoa_GetDisplayName(displays[i]);
             if (!GetDisplayMode(_this, moderef, NULL, link, &mode)) {
                 CVDisplayLinkRelease(link);
+            #if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
                 CGDisplayModeRelease(moderef);
+            #endif
                 SDL_free(display.name);
                 SDL_free(displaydata);
                 continue;
@@ -291,7 +346,12 @@
         }
     }
     SDL_stack_free(displays);
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    [pool release];
+}
+#else
 }}
+#endif
 
 int
 Cocoa_GetDisplayBounds(_THIS, SDL_VideoDisplay * display, SDL_Rect * rect)
@@ -316,7 +376,14 @@
     NSScreen *screen = nil;
 
     /* !!! FIXME: maybe track the NSScreen in SDL_DisplayData? */
+#if defined(MAC_OS_X_VERSION_10_5)
     for (NSScreen *i in screens) {
+#else
+    /* old way to iterate */
+    int j;
+    for (j = 0; j < [screens count]; j++) {
+        NSScreen *i = [screens objectAtIndex:j];
+#endif
         const CGDirectDisplayID thisDisplay = (CGDirectDisplayID) [[[i deviceDescription] objectForKey:@"NSScreenNumber"] unsignedIntValue];
         if (thisDisplay == cgdisplay) {
             screen = i;
@@ -329,6 +396,7 @@
         return -1;
     }
 
+    {
     const CGRect cgrect = CGDisplayBounds(cgdisplay);
     const NSRect frame = [screen visibleFrame];
 
@@ -338,6 +406,7 @@
     rect->y = (int)(cgrect.origin.y + frame.origin.y);
     rect->w = (int)frame.size.width;
     rect->h = (int)frame.size.height;
+    }
 
     return 0;
 }
@@ -391,7 +460,11 @@
     }
 #endif
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
     modes = CGDisplayCopyAllDisplayModes(data->display, dict);
+#else
+    modes = CGDisplayAvailableModes(data->display);
+#endif
 
     if (dict != NULL) {
         CFRelease(dict);
@@ -405,10 +478,16 @@
         CVDisplayLinkCreateWithCGDisplay(data->display, &link);
 
         for (i = 0; i < count; i++) {
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
             CGDisplayModeRef moderef = (CGDisplayModeRef) CFArrayGetValueAtIndex(modes, i);
+#else
+            const void *moderef = CFArrayGetValueAtIndex(modes, i);
+#endif
             SDL_DisplayMode mode;
             if (GetDisplayMode(_this, moderef, modes, link, &mode)) {
+                #if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
                 CGDisplayModeRetain(moderef);
+                #endif
                 SDL_AddDisplayMode(display, &mode);
             }
         }
@@ -433,7 +512,11 @@
 
     if (data == display->desktop_mode.driverdata) {
         /* Restoring desktop mode */
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
         CGDisplaySetDisplayMode(displaydata->display, data->moderef, NULL);
+#else
+        CGDisplaySwitchToMode(displaydata->display, data->moderef);
+#endif
 
         if (CGDisplayIsMain(displaydata->display)) {
             CGReleaseAllDisplays();
@@ -458,7 +541,11 @@
         }
 
         /* Do the physical switch */
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
         result = CGDisplaySetDisplayMode(displaydata->display, data->moderef, NULL);
+#else
+        result = CGDisplaySwitchToMode(displaydata->display, data->moderef);
+#endif
         if (result != kCGErrorSuccess) {
             CG_SetError("CGDisplaySwitchToMode()", result);
             goto ERR_NO_SWITCH;
@@ -503,11 +590,15 @@
         }
 
         mode = (SDL_DisplayModeData *) display->desktop_mode.driverdata;
+        #if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
         CGDisplayModeRelease(mode->moderef);
+        #endif
 
         for (j = 0; j < display->num_display_modes; j++) {
             mode = (SDL_DisplayModeData*) display->display_modes[j].driverdata;
+        #if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
             CGDisplayModeRelease(mode->moderef);
+        #endif
         }
 
     }
diff -ru SDL2-2.0.6-orig/src/video/cocoa/SDL_cocoamouse.h SDL2-2.0.6-tiger/src/video/cocoa/SDL_cocoamouse.h
--- SDL2-2.0.6-orig/src/video/cocoa/SDL_cocoamouse.h	2017-09-22 20:51:01.000000000 +0200
+++ SDL2-2.0.6-tiger/src/video/cocoa/SDL_cocoamouse.h	2018-05-24 21:41:29.000000000 +0200
@@ -25,6 +25,10 @@
 
 #include "SDL_cocoavideo.h"
 
+#if !defined(MAC_OS_X_VERSION_10_5)
+typedef float CGFloat;
+#endif
+
 extern void Cocoa_InitMouse(_THIS);
 extern void Cocoa_HandleMouseEvent(_THIS, NSEvent * event);
 extern void Cocoa_HandleMouseWheel(SDL_Window *window, NSEvent * event);
diff -ru SDL2-2.0.6-orig/src/video/cocoa/SDL_cocoamouse.m SDL2-2.0.6-tiger/src/video/cocoa/SDL_cocoamouse.m
--- SDL2-2.0.6-orig/src/video/cocoa/SDL_cocoamouse.m	2017-09-22 20:51:01.000000000 +0200
+++ SDL2-2.0.6-tiger/src/video/cocoa/SDL_cocoamouse.m	2018-05-24 22:52:21.000000000 +0200
@@ -67,8 +67,13 @@
 
 static SDL_Cursor *
 Cocoa_CreateDefaultCursor()
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     NSCursor *nscursor;
     SDL_Cursor *cursor = NULL;
 
@@ -82,13 +87,25 @@
         }
     }
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    [pool release];
+#endif
     return cursor;
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+}
+#endif
 
 static SDL_Cursor *
 Cocoa_CreateCursor(SDL_Surface * surface, int hot_x, int hot_y)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     NSImage *nsimage;
     NSCursor *nscursor = NULL;
     SDL_Cursor *cursor = NULL;
@@ -107,13 +124,25 @@
         }
     }
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    [pool release];
+#endif
     return cursor;
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+}
+#endif
 
 static SDL_Cursor *
 Cocoa_CreateSystemCursor(SDL_SystemCursor id)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     NSCursor *nscursor = NULL;
     SDL_Cursor *cursor = NULL;
 
@@ -147,7 +176,9 @@
         nscursor = [NSCursor closedHandCursor];
         break;
     case SDL_SYSTEM_CURSOR_NO:
+        if ([NSCursor respondsToSelector:@selector(operationNotAllowedCursor)]) {
         nscursor = [NSCursor operationNotAllowedCursor];
+        }
         break;
     case SDL_SYSTEM_CURSOR_HAND:
         nscursor = [NSCursor pointingHandCursor];
@@ -166,23 +197,45 @@
         }
     }
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    [pool release];
+#endif
     return cursor;
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+}
+#endif
 
 static void
 Cocoa_FreeCursor(SDL_Cursor * cursor)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     NSCursor *nscursor = (NSCursor *)cursor->driverdata;
 
     [nscursor release];
     SDL_free(cursor);
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+    [pool release];
+}
+#endif
 
 static int
 Cocoa_ShowCursor(SDL_Cursor * cursor)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     SDL_VideoDevice *device = SDL_GetVideoDevice();
     SDL_Window *window = (device ? device->windows : NULL);
     for (; window != NULL; window = window->next) {
@@ -193,8 +246,15 @@
                                                 waitUntilDone:NO];
         }
     }
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    [pool release];
+#endif
     return 0;
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+}
+#endif
 
 static SDL_Window *
 SDL_FindWindowAtPoint(const int x, const int y)
@@ -214,6 +274,7 @@
 static int
 Cocoa_WarpMouseGlobal(int x, int y)
 {
+    const CGPoint point = CGPointMake((float)x, (float)y);
     SDL_Mouse *mouse = SDL_GetMouse();
     if (mouse->focus) {
         SDL_WindowData *data = (SDL_WindowData *) mouse->focus->driverdata;
@@ -223,7 +284,6 @@
             return 0;
         }
     }
-    const CGPoint point = CGPointMake((float)x, (float)y);
 
     Cocoa_HandleMouseWarp(point.x, point.y);
 
@@ -261,6 +321,8 @@
 static int
 Cocoa_SetRelativeMouseMode(SDL_bool enabled)
 {
+    CGError result;
+    SDL_WindowData *data;
     /* We will re-apply the relative mode when the window gets focus, if it
      * doesn't have focus right now.
      */
@@ -272,12 +334,11 @@
     /* We will re-apply the relative mode when the window finishes being moved,
      * if it is being moved right now.
      */
-    SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+    data = (SDL_WindowData *) window->driverdata;
     if ([data->listener isMoving]) {
         return 0;
     }
 
-    CGError result;
     if (enabled) {
         DLog("Turning on.");
         result = CGAssociateMouseAndMouseCursorPosition(NO);
@@ -311,11 +372,24 @@
 static Uint32
 Cocoa_GetGlobalMouseState(int *x, int *y)
 {
-    const NSUInteger cocoaButtons = [NSEvent pressedMouseButtons];
+    NSUInteger cocoaButtons = 0;
     const NSPoint cocoaLocation = [NSEvent mouseLocation];
     Uint32 retval = 0;
+#if !defined(MAC_OS_X_VERSION_10_5)
+    int i;
+#endif
 
+    if ([NSEvent respondsToSelector:@selector(pressedMouseButtons)]) {
+        cocoaButtons = [NSEvent pressedMouseButtons];
+    }
+
+#if defined(MAC_OS_X_VERSION_10_5)
     for (NSScreen *screen in [NSScreen screens]) {
+#else
+    /* old way to iterate */
+    for (i = 0; i < [[NSScreen screens] count]; i++) {
+        NSScreen *screen = [[NSScreen screens] objectAtIndex:i];
+#endif
         NSRect frame = [screen frame];
         if (NSMouseInRect(cocoaLocation, frame, NO)) {
             *x = (int) cocoaLocation.x;
@@ -336,6 +410,8 @@
 void
 Cocoa_InitMouse(_THIS)
 {
+    SDL_MouseData *driverdata;
+    NSPoint location;
     SDL_Mouse *mouse = SDL_GetMouse();
 
     mouse->driverdata = SDL_calloc(1, sizeof(SDL_MouseData));
@@ -354,8 +430,8 @@
 
     Cocoa_InitMouseEventTap(mouse->driverdata);
 
-    SDL_MouseData *driverdata = (SDL_MouseData*)mouse->driverdata;
-    const NSPoint location =  [NSEvent mouseLocation];
+    driverdata = (SDL_MouseData*)mouse->driverdata;
+    location =  [NSEvent mouseLocation];
     driverdata->lastMoveX = location.x;
     driverdata->lastMoveY = location.y;
 }
@@ -363,11 +439,21 @@
 void
 Cocoa_HandleMouseEvent(_THIS, NSEvent *event)
 {
+    SDL_Mouse *mouse;
+    SDL_MouseData *driverdata;
+    SDL_bool seenWarp;
     switch ([event type]) {
+#if !defined(MAC_OS_X_VERSION_10_12)
+        case NSMouseMoved:
+        case NSLeftMouseDragged:
+        case NSRightMouseDragged:
+        case NSOtherMouseDragged:
+#else
         case NSEventTypeMouseMoved:
         case NSEventTypeLeftMouseDragged:
         case NSEventTypeRightMouseDragged:
         case NSEventTypeOtherMouseDragged:
+#endif
             break;
 
         default:
@@ -375,15 +461,18 @@
             return;
     }
 
-    SDL_Mouse *mouse = SDL_GetMouse();
-    SDL_MouseData *driverdata = (SDL_MouseData*)mouse->driverdata;
+    mouse = SDL_GetMouse();
+    driverdata = (SDL_MouseData*)mouse->driverdata;
     if (!driverdata) {
         return;  /* can happen when returning from fullscreen Space on shutdown */
     }
 
-    const SDL_bool seenWarp = driverdata->seenWarp;
+    seenWarp = driverdata->seenWarp;
     driverdata->seenWarp = NO;
 
+    {
+    float deltaX;
+    float deltaY;
     const NSPoint location =  [NSEvent mouseLocation];
     const CGFloat lastMoveX = driverdata->lastMoveX;
     const CGFloat lastMoveY = driverdata->lastMoveY;
@@ -404,8 +493,8 @@
         }
     }
 
-    float deltaX = [event deltaX];
-    float deltaY = [event deltaY];
+    deltaX = [event deltaX];
+    deltaY = [event deltaY];
 
     if (seenWarp) {
         deltaX += (lastMoveX - driverdata->lastWarpX);
@@ -415,6 +504,7 @@
     }
 
     SDL_SendMouseMotion(mouse->focus, mouse->mouseID, 1, (int)deltaX, (int)deltaY);
+    }
 }
 
 void
diff -ru SDL2-2.0.6-orig/src/video/cocoa/SDL_cocoaopengl.m SDL2-2.0.6-tiger/src/video/cocoa/SDL_cocoaopengl.m
--- SDL2-2.0.6-orig/src/video/cocoa/SDL_cocoaopengl.m	2017-09-22 20:51:01.000000000 +0200
+++ SDL2-2.0.6-tiger/src/video/cocoa/SDL_cocoaopengl.m	2018-05-24 22:53:55.000000000 +0200
@@ -150,11 +150,20 @@
 
 SDL_GLContext
 Cocoa_GL_CreateContext(_THIS, SDL_Window * window)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool;
+#endif
     SDL_VideoDisplay *display = SDL_GetDisplayForWindow(window);
     SDL_DisplayData *displaydata = (SDL_DisplayData *)display->driverdata;
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1670
     SDL_bool lion_or_later = floor(NSAppKitVersionNumber) > NSAppKitVersionNumber10_6;
+#else
+    SDL_bool lion_or_later = SDL_FALSE;
+#endif
     NSOpenGLPixelFormatAttribute attr[32];
     NSOpenGLPixelFormat *fmt;
     SDLOpenGLContext *context;
@@ -173,9 +182,15 @@
         return NULL;
     }
 
+#if defined(MAC_OS_X_VERSION_10_5)
     attr[i++] = NSOpenGLPFAAllowOfflineRenderers;
+#endif
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    pool = [[NSAutoreleasePool alloc] init];
+#endif
     /* specify a profile if we're on Lion (10.7) or later. */
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
     if (lion_or_later) {
         NSOpenGLPixelFormatAttribute profile = NSOpenGLProfileVersionLegacy;
         if (_this->gl_config.profile_mask == SDL_GL_CONTEXT_PROFILE_CORE) {
@@ -184,6 +199,7 @@
         attr[i++] = NSOpenGLPFAOpenGLProfile;
         attr[i++] = profile;
     }
+#endif
 
     attr[i++] = NSOpenGLPFAColorSize;
     attr[i++] = SDL_BYTESPERPIXEL(display->current_mode.format)*8;
@@ -239,6 +255,9 @@
     fmt = [[NSOpenGLPixelFormat alloc] initWithAttributes:attr];
     if (fmt == nil) {
         SDL_SetError("Failed creating OpenGL pixel format");
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+        [pool release];
+#endif
         return NULL;
     }
 
@@ -252,12 +271,18 @@
 
     if (context == nil) {
         SDL_SetError("Failed creating OpenGL context");
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+        [pool release];
+#endif
         return NULL;
     }
 
     if ( Cocoa_GL_MakeCurrent(_this, window, context) < 0 ) {
         Cocoa_GL_DeleteContext(_this, context);
         SDL_SetError("Failed making OpenGL context current");
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+        [pool release];
+#endif
         return NULL;
     }
 
@@ -272,6 +297,9 @@
         if (!glGetStringFunc) {
             Cocoa_GL_DeleteContext(_this, context);
             SDL_SetError ("Failed getting OpenGL glGetString entry point");
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+            [pool release];
+#endif
             return NULL;
         }
 
@@ -279,12 +307,18 @@
         if (glversion == NULL) {
             Cocoa_GL_DeleteContext(_this, context);
             SDL_SetError ("Failed getting OpenGL context version");
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+            [pool release];
+#endif
             return NULL;
         }
 
         if (SDL_sscanf(glversion, "%d.%d", &glversion_major, &glversion_minor) != 2) {
             Cocoa_GL_DeleteContext(_this, context);
             SDL_SetError ("Failed parsing OpenGL context version");
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+            [pool release];
+#endif
             return NULL;
         }
 
@@ -292,6 +326,9 @@
            ((glversion_major == _this->gl_config.major_version) && (glversion_minor < _this->gl_config.minor_version))) {
             Cocoa_GL_DeleteContext(_this, context);
             SDL_SetError ("Failed creating OpenGL context at version requested");
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+            [pool release];
+#endif
             return NULL;
         }
 
@@ -301,13 +338,25 @@
         /*_this->gl_config.major_version = glversion_major;*/
         /*_this->gl_config.minor_version = glversion_minor;*/
     }
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    [pool release];
+#endif
     return context;
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+}
+#else
 }}
+#endif
 
 int
 Cocoa_GL_MakeCurrent(_THIS, SDL_Window * window, SDL_GLContext context)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     if (context) {
         SDLOpenGLContext *nscontext = (SDLOpenGLContext *)context;
         [nscontext setWindow:window];
@@ -317,8 +366,15 @@
         [NSOpenGLContext clearCurrentContext];
     }
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    [pool release];
+#endif
     return 0;
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+}
+#endif
 
 void
 Cocoa_GL_GetDrawableSize(_THIS, SDL_Window * window, int * w, int * h)
@@ -329,9 +385,11 @@
 
     /* This gives us the correct viewport for a Retina-enabled view, only
      * supported on 10.7+. */
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
     if ([contentView respondsToSelector:@selector(convertRectToBacking:)]) {
         viewport = [contentView convertRectToBacking:viewport];
     }
+#endif
 
     if (w) {
         *w = viewport.size.width;
@@ -344,7 +402,9 @@
 
 int
 Cocoa_GL_SetSwapInterval(_THIS, int interval)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
+#endif
 {
     NSOpenGLContext *nscontext;
     GLint value;
@@ -353,6 +413,9 @@
     if (interval < 0) {  /* no extension for this on Mac OS X at the moment. */
         return SDL_SetError("Late swap tearing currently unsupported");
     }
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
 
     nscontext = (NSOpenGLContext*)SDL_GL_GetCurrentContext();
     if (nscontext != nil) {
@@ -363,13 +426,25 @@
         status = SDL_SetError("No current OpenGL context");
     }
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    [pool release];
+#endif
     return status;
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+}
+#endif
 
 int
 Cocoa_GL_GetSwapInterval(_THIS)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     NSOpenGLContext *nscontext;
     GLint value;
     int status = 0;
@@ -380,28 +455,57 @@
         status = (int)value;
     }
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    [pool release];
+#endif
     return status;
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+}
+#endif
 
 int
 Cocoa_GL_SwapWindow(_THIS, SDL_Window * window)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     SDLOpenGLContext* nscontext = (SDLOpenGLContext*)SDL_GL_GetCurrentContext();
     [nscontext flushBuffer];
     [nscontext updateIfNeeded];
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    [pool release];
+#endif
     return 0;
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+}
+#endif
 
 void
 Cocoa_GL_DeleteContext(_THIS, SDL_GLContext context)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     SDLOpenGLContext *nscontext = (SDLOpenGLContext *)context;
 
     [nscontext setWindow:NULL];
     [nscontext release];
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+    [pool release];
+}
+#endif
 
 #endif /* SDL_VIDEO_OPENGL_CGL */
 
diff -ru SDL2-2.0.6-orig/src/video/cocoa/SDL_cocoashape.m SDL2-2.0.6-tiger/src/video/cocoa/SDL_cocoashape.m
--- SDL2-2.0.6-orig/src/video/cocoa/SDL_cocoashape.m	2017-09-22 20:51:01.000000000 +0200
+++ SDL2-2.0.6-tiger/src/video/cocoa/SDL_cocoashape.m	2018-05-24 22:55:27.000000000 +0200
@@ -35,7 +35,9 @@
     SDL_WindowData* windata = (SDL_WindowData*)window->driverdata;
     [windata->nswindow setOpaque:NO];
 
+    if ([windata->nswindow respondsToSelector:@selector(setStyleMask:)]) {
     [windata->nswindow setStyleMask:NSWindowStyleMaskBorderless];
+    }
 
     SDL_WindowShaper* result = result = malloc(sizeof(SDL_WindowShaper));
     result->window = window;
@@ -73,8 +75,13 @@
 
 int
 Cocoa_SetWindowShape(SDL_WindowShaper *shaper, SDL_Surface *shape, SDL_WindowShapeMode *shape_mode)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     SDL_ShapeData* data = (SDL_ShapeData*)shaper->driverdata;
     SDL_WindowData* windata = (SDL_WindowData*)shaper->window->driverdata;
     SDL_CocoaClosure closure;
@@ -97,8 +104,15 @@
     SDL_TraverseShapeTree(data->shape,&ConvertRects,&closure);
     [closure.path addClip];
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    [pool release];
+#endif
     return 0;
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+}
+#endif
 
 int
 Cocoa_ResizeWindowShape(SDL_Window *window)
diff -ru SDL2-2.0.6-orig/src/video/cocoa/SDL_cocoavideo.h SDL2-2.0.6-tiger/src/video/cocoa/SDL_cocoavideo.h
--- SDL2-2.0.6-orig/src/video/cocoa/SDL_cocoavideo.h	2017-09-22 20:51:01.000000000 +0200
+++ SDL2-2.0.6-tiger/src/video/cocoa/SDL_cocoavideo.h	2018-05-24 21:50:12.000000000 +0200
@@ -25,6 +25,12 @@
 
 #include "SDL_opengl.h"
 
+#if defined(__ALTIVEC__) && !defined(MAC_OS_X_VERSION_10_5)
+/* to cricumvent a bug in Mac OS X 10.4 SDK */
+#define vector __vector
+#include <CoreServices/CoreServices.h>
+#undef vector
+#endif
 #include <ApplicationServices/ApplicationServices.h>
 #include <IOKit/pwr_mgt/IOPMLib.h>
 #include <Cocoa/Cocoa.h>
@@ -40,6 +46,11 @@
 #include "SDL_cocoaopengl.h"
 #include "SDL_cocoawindow.h"
 
+#if !defined(MAC_OS_X_VERSION_10_5)
+typedef long int NSInteger;
+typedef unsigned int NSUInteger;
+#endif
+
 #ifndef MAC_OS_X_VERSION_10_12
 #define DECLARE_EVENT(name) static const NSEventType NSEventType##name = NS##name
 DECLARE_EVENT(LeftMouseDown);
@@ -58,7 +69,9 @@
 DECLARE_EVENT(FlagsChanged);
 #undef DECLARE_EVENT
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
 static const NSEventMask NSEventMaskAny = NSAnyEventMask;
+#endif
 
 #define DECLARE_MODIFIER_FLAG(name) static const NSUInteger NSEventModifierFlag##name = NS##name##KeyMask
 DECLARE_MODIFIER_FLAG(Shift);
@@ -79,11 +92,15 @@
 DECLARE_WINDOW_MASK(Resizable);
 DECLARE_WINDOW_MASK(TexturedBackground);
 DECLARE_WINDOW_MASK(UnifiedTitleAndToolbar);
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
 DECLARE_WINDOW_MASK(FullScreen);
+#endif
 /*DECLARE_WINDOW_MASK(FullSizeContentView);*/ /* Not used, fails compile on older SDKs */
 static const unsigned int NSWindowStyleMaskUtilityWindow = NSUtilityWindowMask;
 static const unsigned int NSWindowStyleMaskDocModalWindow = NSDocModalWindowMask;
+#if defined(MAC_OS_X_VERSION_10_5)
 static const unsigned int NSWindowStyleMaskHUDWindow = NSHUDWindowMask;
+#endif
 #undef DECLARE_WINDOW_MASK
 
 #define DECLARE_ALERT_STYLE(name) static const NSUInteger NSAlertStyle##name = NS##name##AlertStyle
@@ -106,7 +123,9 @@
     NSInteger clipboard_count;
     Uint32 screensaver_activity;
     BOOL screensaver_use_iopm;
+#if defined(MAC_OS_X_VERSION_10_5)
     IOPMAssertionID screensaver_assertion;
+#endif
 
 } SDL_VideoData;
 
diff -ru SDL2-2.0.6-orig/src/video/cocoa/SDL_cocoavideo.m SDL2-2.0.6-tiger/src/video/cocoa/SDL_cocoavideo.m
--- SDL2-2.0.6-orig/src/video/cocoa/SDL_cocoavideo.m	2017-09-22 20:51:01.000000000 +0200
+++ SDL2-2.0.6-tiger/src/video/cocoa/SDL_cocoavideo.m	2018-05-24 21:19:36.000000000 +0200
@@ -22,6 +22,13 @@
 
 #if SDL_VIDEO_DRIVER_COCOA
 
+#if defined(__APPLE__) && defined(__POWERPC__) && !defined(__APPLE_ALTIVEC__)
+#include <altivec.h>
+#undef bool
+#undef vector
+#undef pixel
+#endif
+
 #include "SDL.h"
 #include "SDL_endian.h"
 #include "SDL_cocoavideo.h"
@@ -159,10 +166,15 @@
     Cocoa_InitKeyboard(_this);
     Cocoa_InitMouse(_this);
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
     data->allow_spaces = ((floor(NSAppKitVersionNumber) > NSAppKitVersionNumber10_6) && SDL_GetHintBoolean(SDL_HINT_VIDEO_MAC_FULLSCREEN_SPACES, SDL_TRUE));
 
     /* The IOPM assertion API can disable the screensaver as of 10.7. */
     data->screensaver_use_iopm = floor(NSAppKitVersionNumber) > NSAppKitVersionNumber10_6;
+#else
+    data->allow_spaces = 0;
+    data->screensaver_use_iopm = 0;
+#endif
 
     return 0;
 }
diff -ru SDL2-2.0.6-orig/src/video/cocoa/SDL_cocoawindow.h SDL2-2.0.6-tiger/src/video/cocoa/SDL_cocoawindow.h
--- SDL2-2.0.6-orig/src/video/cocoa/SDL_cocoawindow.h	2017-09-22 20:51:01.000000000 +0200
+++ SDL2-2.0.6-tiger/src/video/cocoa/SDL_cocoawindow.h	2018-05-24 22:32:27.000000000 +0200
@@ -23,6 +23,13 @@
 #ifndef SDL_cocoawindow_h_
 #define SDL_cocoawindow_h_
 
+#if defined(__ALTIVEC__) && !defined(MAC_OS_X_VERSION_10_5)
+/* to cricumvent a bug in Mac OS X 10.4 SDK */
+#define vector __vector
+#include <CoreServices/CoreServices.h>
+#undef vector
+#endif
+
 #import <Cocoa/Cocoa.h>
 
 typedef struct SDL_WindowData SDL_WindowData;
@@ -35,7 +42,11 @@
     PENDING_OPERATION_MINIMIZE
 } PendingWindowOperation;
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
 @interface Cocoa_WindowListener : NSResponder <NSWindowDelegate> {
+#else
+@interface Cocoa_WindowListener : NSResponder {
+#endif
     SDL_WindowData *_data;
     BOOL observingVisible;
     BOOL wasCtrlLeft;
@@ -75,7 +86,9 @@
 -(void) windowDidEnterFullScreen:(NSNotification *) aNotification;
 -(void) windowWillExitFullScreen:(NSNotification *) aNotification;
 -(void) windowDidExitFullScreen:(NSNotification *) aNotification;
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 -(NSApplicationPresentationOptions)window:(NSWindow *)window willUseFullScreenPresentationOptions:(NSApplicationPresentationOptions)proposedOptions;
+#endif
 
 /* See if event is in a drag area, toggle on window dragging. */
 -(BOOL) processHitTest:(NSEvent *)theEvent;
@@ -98,7 +111,17 @@
 -(void) touchesCancelledWithEvent:(NSEvent *) theEvent;
 
 /* Touch event handling */
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 -(void) handleTouches:(NSTouchPhase) phase withEvent:(NSEvent*) theEvent;
+#else
+typedef enum {
+    COCOA_TOUCH_DOWN,
+    COCOA_TOUCH_UP,
+    COCOA_TOUCH_MOVE,
+    COCOA_TOUCH_CANCELLED
+} cocoaTouchType;
+-(void) handleTouches:(cocoaTouchType)type withEvent:(NSEvent*) event;
+#endif
 
 @end
 /* *INDENT-ON* */
diff -ru SDL2-2.0.6-orig/src/video/cocoa/SDL_cocoawindow.m SDL2-2.0.6-tiger/src/video/cocoa/SDL_cocoawindow.m
--- SDL2-2.0.6-orig/src/video/cocoa/SDL_cocoawindow.m	2017-09-22 20:51:01.000000000 +0200
+++ SDL2-2.0.6-tiger/src/video/cocoa/SDL_cocoawindow.m	2018-05-25 10:01:02.000000000 +0200
@@ -23,7 +23,9 @@
 #if SDL_VIDEO_DRIVER_COCOA
 
 #if MAC_OS_X_VERSION_MAX_ALLOWED < 1070
+#if 0
 # error SDL for Mac OS X must be built with a 10.7 SDK or above.
+#endif
 #endif /* MAC_OS_X_VERSION_MAX_ALLOWED < 1070 */
 
 #include "SDL_syswm.h"
@@ -54,7 +56,11 @@
 #define FULLSCREEN_MASK (SDL_WINDOW_FULLSCREEN_DESKTOP | SDL_WINDOW_FULLSCREEN)
 
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+@interface SDLWindow : NSWindow
+#else
 @interface SDLWindow : NSWindow <NSDraggingDestination>
+#endif
 /* These are needed for borderless/fullscreen windows */
 - (BOOL)canBecomeKeyWindow;
 - (BOOL)canBecomeMainWindow;
@@ -136,27 +142,49 @@
 }
 
 - (BOOL)performDragOperation:(id <NSDraggingInfo>)sender
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool;
+#endif
     NSPasteboard *pasteboard = [sender draggingPasteboard];
     NSArray *types = [NSArray arrayWithObject:NSFilenamesPboardType];
     NSString *desiredType = [pasteboard availableTypeFromArray:types];
     SDL_Window *sdlwindow = [self findSDLWindow];
+    NSData *data;
+#if !defined(MAC_OS_X_VERSION_10_5)
+    NSArray *array;
+    int i;
+#endif
 
     if (desiredType == nil) {
         return NO;  /* can't accept anything that's being dropped here. */
     }
 
-    NSData *data = [pasteboard dataForType:desiredType];
+    data = [pasteboard dataForType:desiredType];
     if (data == nil) {
         return NO;
     }
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    pool = [[NSAutoreleasePool alloc] init];
+#endif
+
     SDL_assert([desiredType isEqualToString:NSFilenamesPboardType]);
+#if defined(MAC_OS_X_VERSION_10_5)
     NSArray *array = [pasteboard propertyListForType:@"NSFilenamesPboardType"];
 
     for (NSString *path in array) {
+#else
+    array = [pasteboard propertyListForType:@"NSFilenamesPboardType"];
+    /* old way to iterate */
+    for (i = 0; i < [array count]; i++) {
+        NSString *path = [array objectAtIndex:i];
+#endif
         NSURL *fileURL = [NSURL fileURLWithPath:path];
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
         NSNumber *isAlias = nil;
 
         [fileURL getResourceValue:&isAlias forKey:NSURLIsAliasFileKey error:nil];
@@ -177,15 +205,26 @@
                 }
             }
         }
+#endif
 
         if (!SDL_SendDropFile(sdlwindow, [[fileURL path] UTF8String])) {
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+            [pool release];
+#endif
             return NO;
         }
     }
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    [pool release];
+#endif
     SDL_SendDropComplete(sdlwindow);
     return YES;
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+}
+#else
 }}
+#endif
 
 - (BOOL)wantsPeriodicDraggingUpdates
 {
@@ -226,7 +265,14 @@
     NSOpenGLContext *currentContext = [NSOpenGLContext currentContext];
     NSMutableArray *contexts = data->nscontexts;
     @synchronized (contexts) {
+#if defined(MAC_OS_X_VERSION_10_5)
         for (SDLOpenGLContext *context in contexts) {
+#else
+        /* old way to iterate */
+        int i;
+        for (i = 0; i < [contexts count]; i++) {
+            SDLOpenGLContext *context = [contexts objectAtIndex:i];
+#endif
             if (context == currentContext) {
                 [context update];
             } else {
@@ -274,7 +320,9 @@
         [[nswindow contentView] setNextResponder:nil];
     }
 
+    if ([nswindow respondsToSelector:@selector(setStyleMask:)]) {
     [nswindow setStyleMask:style];
+    }
 
     /* The view responder chain gets messed with during setStyleMask */
     if ([[nswindow contentView] nextResponder] != data->listener) {
@@ -313,11 +361,13 @@
         [center addObserver:self selector:@selector(windowDidDeminiaturize:) name:NSWindowDidDeminiaturizeNotification object:window];
         [center addObserver:self selector:@selector(windowDidBecomeKey:) name:NSWindowDidBecomeKeyNotification object:window];
         [center addObserver:self selector:@selector(windowDidResignKey:) name:NSWindowDidResignKeyNotification object:window];
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
         [center addObserver:self selector:@selector(windowDidChangeBackingProperties:) name:NSWindowDidChangeBackingPropertiesNotification object:window];
         [center addObserver:self selector:@selector(windowWillEnterFullScreen:) name:NSWindowWillEnterFullScreenNotification object:window];
         [center addObserver:self selector:@selector(windowDidEnterFullScreen:) name:NSWindowDidEnterFullScreenNotification object:window];
         [center addObserver:self selector:@selector(windowWillExitFullScreen:) name:NSWindowWillExitFullScreenNotification object:window];
         [center addObserver:self selector:@selector(windowDidExitFullScreen:) name:NSWindowDidExitFullScreenNotification object:window];
+#endif
         [center addObserver:self selector:@selector(windowDidFailToEnterFullScreen:) name:@"NSWindowDidFailToEnterFullScreenNotification" object:window];
         [center addObserver:self selector:@selector(windowDidFailToExitFullScreen:) name:@"NSWindowDidFailToExitFullScreenNotification" object:window];
     } else {
@@ -338,7 +388,9 @@
 
     [view setNextResponder:self];
 
+    if ([view respondsToSelector:@selector(setAcceptsTouchEvents:)]) {
     [view setAcceptsTouchEvents:YES];
+    }
 }
 
 - (void)observeValueForKeyPath:(NSString *)keyPath
@@ -408,7 +460,9 @@
     inFullscreenTransition = YES;
 
     /* you need to be FullScreenPrimary, or toggleFullScreen doesn't work. Unset it again in windowDidExitFullScreen. */
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
     [nswindow setCollectionBehavior:NSWindowCollectionBehaviorFullScreenPrimary];
+#endif
     [nswindow performSelectorOnMainThread: @selector(toggleFullScreen:) withObject:nswindow waitUntilDone:NO];
     return YES;
 }
@@ -444,11 +498,13 @@
         [center removeObserver:self name:NSWindowDidDeminiaturizeNotification object:window];
         [center removeObserver:self name:NSWindowDidBecomeKeyNotification object:window];
         [center removeObserver:self name:NSWindowDidResignKeyNotification object:window];
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
         [center removeObserver:self name:NSWindowDidChangeBackingPropertiesNotification object:window];
         [center removeObserver:self name:NSWindowWillEnterFullScreenNotification object:window];
         [center removeObserver:self name:NSWindowDidEnterFullScreenNotification object:window];
         [center removeObserver:self name:NSWindowWillExitFullScreenNotification object:window];
         [center removeObserver:self name:NSWindowDidExitFullScreenNotification object:window];
+#endif
         [center removeObserver:self name:@"NSWindowDidFailToEnterFullScreenNotification" object:window];
         [center removeObserver:self name:@"NSWindowDidFailToExitFullScreenNotification" object:window];
     } else {
@@ -628,9 +684,11 @@
         [NSMenu setMenuBarVisible:NO];
     }
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
     const unsigned int newflags = [NSEvent modifierFlags] & NSEventModifierFlagCapsLock;
     _data->videodata->modifierFlags = (_data->videodata->modifierFlags & ~NSEventModifierFlagCapsLock) | newflags;
     SDL_ToggleModState(KMOD_CAPS, newflags != 0);
+#endif
 }
 
 - (void)windowDidResignKey:(NSNotification *)aNotification
@@ -657,6 +715,7 @@
 
 - (void)windowDidChangeBackingProperties:(NSNotification *)aNotification
 {
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
     NSNumber *oldscale = [[aNotification userInfo] objectForKey:NSBackingPropertyOldScaleFactorKey];
 
     if (inFullscreenTransition) {
@@ -669,6 +728,7 @@
         _data->window->h = 0;
         [self windowDidResize:aNotification];
     }
+#endif
 }
 
 - (void)windowWillEnterFullScreen:(NSNotification *)aNotification
@@ -777,12 +837,14 @@
         [nswindow miniaturize:nil];
     } else {
         /* Adjust the fullscreen toggle button and readd menu now that we're here. */
+#if MAC_OS_X_VERSION_MIN_REQUIRED > 1070
         if (window->flags & SDL_WINDOW_RESIZABLE) {
             /* resizable windows are Spaces-friendly: they get the "go fullscreen" toggle button on their titlebar. */
             [nswindow setCollectionBehavior:NSWindowCollectionBehaviorFullScreenPrimary];
         } else {
             [nswindow setCollectionBehavior:NSWindowCollectionBehaviorManaged];
         }
+#endif
         [NSMenu setMenuBarVisible:YES];
 
         pendingWindowOperation = PENDING_OPERATION_NONE;
@@ -825,6 +887,7 @@
     }
 }
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 -(NSApplicationPresentationOptions)window:(NSWindow *)window willUseFullScreenPresentationOptions:(NSApplicationPresentationOptions)proposedOptions
 {
     if ((_data->window->flags & SDL_WINDOW_FULLSCREEN_DESKTOP) == SDL_WINDOW_FULLSCREEN_DESKTOP) {
@@ -833,6 +896,7 @@
         return proposedOptions;
     }
 }
+#endif
 
 
 /* We'll respond to key events by doing nothing so we don't beep.
@@ -1059,6 +1123,7 @@
 
 - (void)touchesBeganWithEvent:(NSEvent *) theEvent
 {
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
     NSSet *touches = [theEvent touchesMatchingPhase:NSTouchPhaseAny inView:nil];
     int existingTouchCount = 0;
 
@@ -1079,25 +1144,89 @@
 
     DLog("Began Fingers: %lu .. existing: %d", (unsigned long)[touches count], existingTouchCount);
     [self handleTouches:NSTouchPhaseBegan withEvent:theEvent];
+#endif
 }
 
 - (void)touchesMovedWithEvent:(NSEvent *) theEvent
 {
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
     [self handleTouches:NSTouchPhaseMoved withEvent:theEvent];
+#endif
 }
 
 - (void)touchesEndedWithEvent:(NSEvent *) theEvent
 {
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
     [self handleTouches:NSTouchPhaseEnded withEvent:theEvent];
+#endif
 }
 
 - (void)touchesCancelledWithEvent:(NSEvent *) theEvent
 {
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
     [self handleTouches:NSTouchPhaseCancelled withEvent:theEvent];
+#endif
 }
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
 - (void)handleTouches:(NSTouchPhase) phase withEvent:(NSEvent *) theEvent
+#else
+- (void)handleTouches:(cocoaTouchType)type withEvent:(NSEvent *)event
+#endif
 {
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    NSSet *touches = 0;
+    NSEnumerator *enumerator;
+    NSTouch *touch;
+
+    switch (type) {
+        case COCOA_TOUCH_DOWN:
+            touches = [event touchesMatchingPhase:NSTouchPhaseBegan inView:nil];
+            break;
+        case COCOA_TOUCH_UP:
+            touches = [event touchesMatchingPhase:NSTouchPhaseEnded inView:nil];
+            break;
+        case COCOA_TOUCH_CANCELLED:
+            touches = [event touchesMatchingPhase:NSTouchPhaseCancelled inView:nil];
+            break;
+        case COCOA_TOUCH_MOVE:
+            touches = [event touchesMatchingPhase:NSTouchPhaseMoved inView:nil];
+            break;
+    }
+
+    enumerator = [touches objectEnumerator];
+    touch = (NSTouch*)[enumerator nextObject];
+    while (touch) {
+        const SDL_TouchID touchId = (SDL_TouchID)(intptr_t)[touch device];
+        if (!SDL_GetTouch(touchId)) {
+            if (SDL_AddTouch(touchId, "") < 0) {
+                return;
+            }
+        }
+
+        const SDL_FingerID fingerId = (SDL_FingerID)(intptr_t)[touch identity];
+        float x = [touch normalizedPosition].x;
+        float y = [touch normalizedPosition].y;
+        /* Make the origin the upper left instead of the lower left */
+        y = 1.0f - y;
+
+        switch (type) {
+        case COCOA_TOUCH_DOWN:
+            SDL_SendTouch(touchId, fingerId, SDL_TRUE, x, y, 1.0f);
+            break;
+        case COCOA_TOUCH_UP:
+        case COCOA_TOUCH_CANCELLED:
+            SDL_SendTouch(touchId, fingerId, SDL_FALSE, x, y, 1.0f);
+            break;
+        case COCOA_TOUCH_MOVE:
+            SDL_SendTouchMotion(touchId, fingerId, x, y, 1.0f);
+            break;
+        }
+
+        touch = (NSTouch*)[enumerator nextObject];
+     }
+#else
     NSSet *touches = [theEvent touchesMatchingPhase:phase inView:nil];
 
     for (NSTouch *touch in touches) {
@@ -1127,7 +1256,9 @@
             break;
         }
     }
+#endif
 }
+#endif
 
 @end
 
@@ -1194,8 +1325,13 @@
 
 static int
 SetupWindowData(_THIS, SDL_Window * window, NSWindow *nswindow, SDL_bool created)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool;
+#endif
     SDL_VideoData *videodata = (SDL_VideoData *) _this->driverdata;
     SDL_WindowData *data;
 
@@ -1210,6 +1346,9 @@
     data->videodata = videodata;
     data->nscontexts = [[NSMutableArray alloc] init];
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    pool = [[NSAutoreleasePool alloc] init];
+#endif
     /* Create an event listener for the window */
     data->listener = [[Cocoa_WindowListener alloc] init];
 
@@ -1270,15 +1409,27 @@
      */
     [nswindow setOneShot:NO];
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    [pool release];
+#endif
     /* All done! */
     window->driverdata = data;
     return 0;
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+}
+#else
 }}
+#endif
 
 int
 Cocoa_CreateWindow(_THIS, SDL_Window * window)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     SDL_VideoData *videodata = (SDL_VideoData *) _this->driverdata;
     NSWindow *nswindow;
     SDL_VideoDisplay *display = SDL_GetDisplayForWindow(window);
@@ -1286,6 +1437,10 @@
     SDL_Rect bounds;
     NSUInteger style;
     NSArray *screens = [NSScreen screens];
+#if !defined(MAC_OS_X_VERSION_10_5)
+    NSScreen *screen = nil;
+    int i;
+#endif
 
     Cocoa_GetDisplayBounds(_this, display, &bounds);
     rect.origin.x = window->x;
@@ -1297,8 +1452,14 @@
     style = GetWindowStyle(window);
 
     /* Figure out which screen to place this window */
+#if defined(MAC_OS_X_VERSION_10_5)
     NSScreen *screen = nil;
     for (NSScreen *candidate in screens) {
+#else
+    /* old way to iterate */
+    for (i = 0; i < [screens count]; i++) {
+        NSScreen *candidate = [screens objectAtIndex:i];
+#endif
         NSRect screenRect = [candidate frame];
         if (rect.origin.x >= screenRect.origin.x &&
             rect.origin.x < screenRect.origin.x + screenRect.size.width &&
@@ -1319,6 +1480,7 @@
     [nswindow setBackgroundColor:[NSColor blackColor]];
 
     if (videodata->allow_spaces) {
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
         SDL_assert(floor(NSAppKitVersionNumber) > NSAppKitVersionNumber10_6);
         SDL_assert([nswindow respondsToSelector:@selector(toggleFullScreen:)]);
         /* we put FULLSCREEN_DESKTOP windows in their own Space, without a toggle button or menubar, later */
@@ -1326,6 +1488,7 @@
             /* resizable windows are Spaces-friendly: they get the "go fullscreen" toggle button on their titlebar. */
             [nswindow setCollectionBehavior:NSWindowCollectionBehaviorFullScreenPrimary];
         }
+#endif
     }
 
     /* Create a default view for this window */
@@ -1344,18 +1507,30 @@
 
     /* Allow files and folders to be dragged onto the window by users */
     [nswindow registerForDraggedTypes:[NSArray arrayWithObject:(NSString *)kUTTypeFileURL]];
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    [pool release];
+#endif
 
     if (SetupWindowData(_this, window, nswindow, SDL_TRUE) < 0) {
         [nswindow release];
         return -1;
     }
     return 0;
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+}
+#endif
 
 int
 Cocoa_CreateWindowFrom(_THIS, SDL_Window * window, const void *data)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     NSWindow *nswindow = (NSWindow *) data;
     NSString *title;
 
@@ -1366,34 +1541,64 @@
     }
 
     return SetupWindowData(_this, window, nswindow, SDL_FALSE);
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+    [pool release];
+}
+#endif
 
 void
 Cocoa_SetWindowTitle(_THIS, SDL_Window * window)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     const char *title = window->title ? window->title : "";
     NSWindow *nswindow = ((SDL_WindowData *) window->driverdata)->nswindow;
     NSString *string = [[NSString alloc] initWithUTF8String:title];
     [nswindow setTitle:string];
     [string release];
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+    [pool release];
+}
+#endif
 
 void
 Cocoa_SetWindowIcon(_THIS, SDL_Window * window, SDL_Surface * icon)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     NSImage *nsimage = Cocoa_CreateImage(icon);
 
     if (nsimage) {
         [NSApp setApplicationIconImage:nsimage];
     }
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+    [pool release];
+}
+#endif
 
 void
 Cocoa_SetWindowPosition(_THIS, SDL_Window * window)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     SDL_WindowData *windata = (SDL_WindowData *) window->driverdata;
     NSWindow *nswindow = windata->nswindow;
     NSRect rect;
@@ -1411,12 +1616,22 @@
     s_moveHack = moveHack;
 
     ScheduleContextUpdates(windata);
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+    [pool release];
+}
+#endif
 
 void
 Cocoa_SetWindowSize(_THIS, SDL_Window * window)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     SDL_WindowData *windata = (SDL_WindowData *) window->driverdata;
     NSWindow *nswindow = windata->nswindow;
     NSRect rect;
@@ -1438,12 +1653,22 @@
     s_moveHack = moveHack;
 
     ScheduleContextUpdates(windata);
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+    [pool release];
+}
+#endif
 
 void
 Cocoa_SetWindowMinimumSize(_THIS, SDL_Window * window)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     SDL_WindowData *windata = (SDL_WindowData *) window->driverdata;
 
     NSSize minSize;
@@ -1451,12 +1676,22 @@
     minSize.height = window->min_h;
 
     [windata->nswindow setContentMinSize:minSize];
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+    [pool release];
+}
+#endif
 
 void
 Cocoa_SetWindowMaximumSize(_THIS, SDL_Window * window)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     SDL_WindowData *windata = (SDL_WindowData *) window->driverdata;
 
     NSSize maxSize;
@@ -1464,12 +1699,22 @@
     maxSize.height = window->max_h;
 
     [windata->nswindow setContentMaxSize:maxSize];
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+    [pool release];
+}
+#endif
 
 void
 Cocoa_ShowWindow(_THIS, SDL_Window * window)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     SDL_WindowData *windowData = ((SDL_WindowData *) window->driverdata);
     NSWindow *nswindow = windowData->nswindow;
 
@@ -1478,21 +1723,41 @@
         [nswindow makeKeyAndOrderFront:nil];
         [windowData->listener resumeVisibleObservation];
     }
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+    [pool release];
+}
+#endif
 
 void
 Cocoa_HideWindow(_THIS, SDL_Window * window)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     NSWindow *nswindow = ((SDL_WindowData *) window->driverdata)->nswindow;
 
     [nswindow orderOut:nil];
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+    [pool release];
+}
+#endif
 
 void
 Cocoa_RaiseWindow(_THIS, SDL_Window * window)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     SDL_WindowData *windowData = ((SDL_WindowData *) window->driverdata);
     NSWindow *nswindow = windowData->nswindow;
 
@@ -1505,24 +1770,44 @@
         [nswindow makeKeyAndOrderFront:nil];
     }
     [windowData->listener resumeVisibleObservation];
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+    [pool release];
+}
+#endif
 
 void
 Cocoa_MaximizeWindow(_THIS, SDL_Window * window)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     SDL_WindowData *windata = (SDL_WindowData *) window->driverdata;
     NSWindow *nswindow = windata->nswindow;
 
     [nswindow zoom:nil];
 
     ScheduleContextUpdates(windata);
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+    [pool release];
+}
+#endif
 
 void
 Cocoa_MinimizeWindow(_THIS, SDL_Window * window)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
     NSWindow *nswindow = data->nswindow;
 
@@ -1531,12 +1816,22 @@
     } else {
         [nswindow miniaturize:nil];
     }
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+    [pool release];
+}
+#endif
 
 void
 Cocoa_RestoreWindow(_THIS, SDL_Window * window)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     NSWindow *nswindow = ((SDL_WindowData *) window->driverdata)->nswindow;
 
     if ([nswindow isMiniaturized]) {
@@ -1544,23 +1839,44 @@
     } else if ((window->flags & SDL_WINDOW_RESIZABLE) && [nswindow isZoomed]) {
         [nswindow zoom:nil];
     }
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+    [pool release];
+}
+#endif
 
 void
 Cocoa_SetWindowBordered(_THIS, SDL_Window * window, SDL_bool bordered)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     if (SetWindowStyle(window, GetWindowStyle(window))) {
         if (bordered) {
             Cocoa_SetWindowTitle(_this, window);  /* this got blanked out. */
         }
     }
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+    [pool release];
+}
+#endif
+
 
 void
 Cocoa_SetWindowResizable(_THIS, SDL_Window * window, SDL_bool resizable)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     /* Don't set this if we're in a space!
      * The window will get permanently stuck if resizable is false.
      * -flibit
@@ -1570,12 +1886,23 @@
     if (![listener isInFullscreenSpace]) {
         SetWindowStyle(window, GetWindowStyle(window));
     }
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+    [pool release];
+}
+#endif
+
 
 void
 Cocoa_SetWindowFullscreen(_THIS, SDL_Window * window, SDL_VideoDisplay * display, SDL_bool fullscreen)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
     NSWindow *nswindow = data->nswindow;
     NSRect rect;
@@ -1587,6 +1914,7 @@
 
     if (fullscreen) {
         SDL_Rect bounds;
+        NSRect screenRect;
 
         Cocoa_GetDisplayBounds(_this, display, &bounds);
         rect.origin.x = bounds.x;
@@ -1596,12 +1924,14 @@
         ConvertNSRect([nswindow screen], fullscreen, &rect);
 
         /* Hack to fix origin on Mac OS X 10.4 */
-        NSRect screenRect = [[nswindow screen] frame];
+        screenRect = [[nswindow screen] frame];
         if (screenRect.size.height >= 1.0f) {
             rect.origin.y += (screenRect.size.height - rect.size.height);
         }
 
+        if ([nswindow respondsToSelector:@selector(setStyleMask:)]) {
         [nswindow setStyleMask:NSWindowStyleMaskBorderless];
+        }
     } else {
         rect.origin.x = window->windowed.x;
         rect.origin.y = window->windowed.y;
@@ -1609,7 +1939,9 @@
         rect.size.height = window->windowed.h;
         ConvertNSRect([nswindow screen], fullscreen, &rect);
 
+        if ([nswindow respondsToSelector:@selector(setStyleMask:)]) {
         [nswindow setStyleMask:GetWindowStyle(window)];
+        }
 
         /* Hack to restore window decorations on Mac OS X 10.10 */
         NSRect frameRect = [nswindow frame];
@@ -1646,7 +1978,12 @@
     }
 
     ScheduleContextUpdates(data);
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+    [pool release];
+}
+#endif
 
 int
 Cocoa_SetWindowGammaRamp(_THIS, SDL_Window * window, const Uint16 * ramp)
@@ -1736,11 +2073,20 @@
 
 void
 Cocoa_DestroyWindow(_THIS, SDL_Window * window)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
 
     if (data) {
+#if !defined(MAC_OS_X_VERSION_10_5)
+        int i;
+        NSArray *contexts;
+#endif
         if ([data->listener isInFullscreenSpace]) {
             [NSMenu setMenuBarVisible:YES];
         }
@@ -1750,8 +2096,15 @@
             [data->nswindow close];
         }
 
+#if defined(MAC_OS_X_VERSION_10_5)
         NSArray *contexts = [[data->nscontexts copy] autorelease];
         for (SDLOpenGLContext *context in contexts) {
+#else
+        contexts = [[data->nscontexts copy] autorelease];
+        /* old way to iterate */
+        for (i = 0; i < [contexts count]; i++) {
+            SDLOpenGLContext *context = [contexts objectAtIndex:i];
+#endif
             /* Calling setWindow:NULL causes the context to remove itself from the context list. */            
             [context setWindow:NULL];
         }
@@ -1760,7 +2113,12 @@
         SDL_free(data);
     }
     window->driverdata = NULL;
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+    [pool release];
+}
+#endif
 
 SDL_bool
 Cocoa_GetWindowWMInfo(_THIS, SDL_Window * window, SDL_SysWMinfo * info)
@@ -1792,8 +2150,13 @@
 
 SDL_bool
 Cocoa_SetWindowFullscreenSpace(SDL_Window * window, SDL_bool state)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     SDL_bool succeeded = SDL_FALSE;
     SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
 
@@ -1824,8 +2187,15 @@
         succeeded = SDL_TRUE;
     }
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    [pool release];
+#endif
     return succeeded;
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+}
+#endif
 
 int
 Cocoa_SetWindowHitTest(SDL_Window * window, SDL_bool enabled)
Only in SDL2-2.0.6-tiger/test: CompareSurfaces0001_Reference.bmp
Only in SDL2-2.0.6-tiger/test: CompareSurfaces0001_TestOutput.bmp
Only in SDL2-2.0.6-tiger/test: CompareSurfaces0002_Reference.bmp
Only in SDL2-2.0.6-tiger/test: CompareSurfaces0002_TestOutput.bmp
Only in SDL2-2.0.6-tiger/test: CompareSurfaces0003_Reference.bmp
Only in SDL2-2.0.6-tiger/test: CompareSurfaces0003_TestOutput.bmp
Only in SDL2-2.0.6-tiger/test: CompareSurfaces0004_Reference.bmp
Only in SDL2-2.0.6-tiger/test: CompareSurfaces0004_TestOutput.bmp
Only in SDL2-2.0.6-tiger/test: CompareSurfaces0005_Reference.bmp
Only in SDL2-2.0.6-tiger/test: CompareSurfaces0005_TestOutput.bmp
Only in SDL2-2.0.6-tiger/test: CompareSurfaces0011_Reference.bmp
Only in SDL2-2.0.6-tiger/test: CompareSurfaces0011_TestOutput.bmp
Only in SDL2-2.0.6-tiger/test: CompareSurfaces0016_Reference.bmp
Only in SDL2-2.0.6-tiger/test: CompareSurfaces0016_TestOutput.bmp
Only in SDL2-2.0.6-tiger/test: CompareSurfaces0021_Reference.bmp
Only in SDL2-2.0.6-tiger/test: CompareSurfaces0021_TestOutput.bmp
Only in SDL2-2.0.6-tiger/test: CompareSurfaces0026_Reference.bmp
Only in SDL2-2.0.6-tiger/test: CompareSurfaces0026_TestOutput.bmp
Only in SDL2-2.0.6-tiger/test: CompareSurfaces0027_Reference.bmp
Only in SDL2-2.0.6-tiger/test: CompareSurfaces0027_TestOutput.bmp
Only in SDL2-2.0.6-tiger/test: CompareSurfaces0028_Reference.bmp
Only in SDL2-2.0.6-tiger/test: CompareSurfaces0028_TestOutput.bmp
Only in SDL2-2.0.6-tiger/test: CompareSurfaces0029_Reference.bmp
Only in SDL2-2.0.6-tiger/test: CompareSurfaces0029_TestOutput.bmp
Only in SDL2-2.0.6-tiger/test: CompareSurfaces0030_Reference.bmp
Only in SDL2-2.0.6-tiger/test: CompareSurfaces0030_TestOutput.bmp
Only in SDL2-2.0.6-tiger/test: CompareSurfaces0031_Reference.bmp
Only in SDL2-2.0.6-tiger/test: CompareSurfaces0031_TestOutput.bmp
Only in SDL2-2.0.6-tiger/test: CompareSurfaces0032_Reference.bmp
Only in SDL2-2.0.6-tiger/test: CompareSurfaces0032_TestOutput.bmp
Only in SDL2-2.0.6-tiger/test: CompareSurfaces0033_Reference.bmp
Only in SDL2-2.0.6-tiger/test: CompareSurfaces0033_TestOutput.bmp
Only in SDL2-2.0.6-tiger/test: Makefile
Only in SDL2-2.0.6-tiger/test: checkkeys
Only in SDL2-2.0.6-tiger/test: checkkeys.dSYM
Only in SDL2-2.0.6-tiger/test: config.log
Only in SDL2-2.0.6-tiger/test: config.status
Only in SDL2-2.0.6-tiger/test: controllermap
Only in SDL2-2.0.6-tiger/test: controllermap.dSYM
Only in SDL2-2.0.6-tiger/test: loopwave
Only in SDL2-2.0.6-tiger/test: loopwave.dSYM
Only in SDL2-2.0.6-tiger/test: loopwavequeue
Only in SDL2-2.0.6-tiger/test: loopwavequeue.dSYM
Only in SDL2-2.0.6-tiger/test: testatomic
Only in SDL2-2.0.6-tiger/test: testatomic.dSYM
Only in SDL2-2.0.6-tiger/test: testaudiocapture
Only in SDL2-2.0.6-tiger/test: testaudiocapture.dSYM
Only in SDL2-2.0.6-tiger/test: testaudiohotplug
Only in SDL2-2.0.6-tiger/test: testaudiohotplug.dSYM
Only in SDL2-2.0.6-tiger/test: testaudioinfo
Only in SDL2-2.0.6-tiger/test: testaudioinfo.dSYM
Only in SDL2-2.0.6-tiger/test: testautomation
Only in SDL2-2.0.6-tiger/test: testautomation.dSYM
Only in SDL2-2.0.6-tiger/test: testbounds
Only in SDL2-2.0.6-tiger/test: testbounds.dSYM
Only in SDL2-2.0.6-tiger/test: testcustomcursor
Only in SDL2-2.0.6-tiger/test: testcustomcursor.dSYM
Only in SDL2-2.0.6-tiger/test: testdisplayinfo
Only in SDL2-2.0.6-tiger/test: testdisplayinfo.dSYM
Only in SDL2-2.0.6-tiger/test: testdraw2
Only in SDL2-2.0.6-tiger/test: testdraw2.dSYM
Only in SDL2-2.0.6-tiger/test: testdrawchessboard
Only in SDL2-2.0.6-tiger/test: testdrawchessboard.dSYM
Only in SDL2-2.0.6-tiger/test: testdropfile
Only in SDL2-2.0.6-tiger/test: testdropfile.dSYM
Only in SDL2-2.0.6-tiger/test: testerror
Only in SDL2-2.0.6-tiger/test: testerror.dSYM
Only in SDL2-2.0.6-tiger/test: testfile
Only in SDL2-2.0.6-tiger/test: testfile.dSYM
Only in SDL2-2.0.6-tiger/test: testfilesystem
Only in SDL2-2.0.6-tiger/test: testfilesystem.dSYM
Only in SDL2-2.0.6-tiger/test: testgamecontroller
Only in SDL2-2.0.6-tiger/test: testgamecontroller.dSYM
Only in SDL2-2.0.6-tiger/test: testgesture
Only in SDL2-2.0.6-tiger/test: testgesture.dSYM
Only in SDL2-2.0.6-tiger/test: testgl2
Only in SDL2-2.0.6-tiger/test: testgl2.dSYM
Only in SDL2-2.0.6-tiger/test: testgles
Only in SDL2-2.0.6-tiger/test: testgles.dSYM
Only in SDL2-2.0.6-tiger/test: testgles2
Only in SDL2-2.0.6-tiger/test: testgles2.dSYM
Only in SDL2-2.0.6-tiger/test: testhaptic
Only in SDL2-2.0.6-tiger/test: testhaptic.dSYM
Only in SDL2-2.0.6-tiger/test: testhittesting
Only in SDL2-2.0.6-tiger/test: testhittesting.dSYM
Only in SDL2-2.0.6-tiger/test: testhotplug
Only in SDL2-2.0.6-tiger/test: testhotplug.dSYM
Only in SDL2-2.0.6-tiger/test: testiconv
Only in SDL2-2.0.6-tiger/test: testiconv.dSYM
Only in SDL2-2.0.6-tiger/test: testime
Only in SDL2-2.0.6-tiger/test: testime.dSYM
Only in SDL2-2.0.6-tiger/test: testintersections
Only in SDL2-2.0.6-tiger/test: testintersections.dSYM
Only in SDL2-2.0.6-tiger/test: testjoystick
Only in SDL2-2.0.6-tiger/test: testjoystick.dSYM
Only in SDL2-2.0.6-tiger/test: testkeys
Only in SDL2-2.0.6-tiger/test: testkeys.dSYM
Only in SDL2-2.0.6-tiger/test: testloadso
Only in SDL2-2.0.6-tiger/test: testloadso.dSYM
Only in SDL2-2.0.6-tiger/test: testlock
Only in SDL2-2.0.6-tiger/test: testlock.dSYM
Only in SDL2-2.0.6-tiger/test: testmessage
Only in SDL2-2.0.6-tiger/test: testmessage.dSYM
Only in SDL2-2.0.6-tiger/test: testmultiaudio
Only in SDL2-2.0.6-tiger/test: testmultiaudio.dSYM
Only in SDL2-2.0.6-tiger/test: testnative
Only in SDL2-2.0.6-tiger/test: testnative.dSYM
Only in SDL2-2.0.6-tiger/test: testoverlay2
Only in SDL2-2.0.6-tiger/test: testoverlay2.dSYM
Only in SDL2-2.0.6-tiger/test: testplatform
Only in SDL2-2.0.6-tiger/test: testplatform.dSYM
Only in SDL2-2.0.6-tiger/test: testpower
Only in SDL2-2.0.6-tiger/test: testpower.dSYM
Only in SDL2-2.0.6-tiger/test: testqsort
Only in SDL2-2.0.6-tiger/test: testqsort.dSYM
Only in SDL2-2.0.6-tiger/test: testrelative
Only in SDL2-2.0.6-tiger/test: testrelative.dSYM
Only in SDL2-2.0.6-tiger/test: testrendercopyex
Only in SDL2-2.0.6-tiger/test: testrendercopyex.dSYM
Only in SDL2-2.0.6-tiger/test: testrendertarget
Only in SDL2-2.0.6-tiger/test: testrendertarget.dSYM
Only in SDL2-2.0.6-tiger/test: testresample
Only in SDL2-2.0.6-tiger/test: testresample.dSYM
Only in SDL2-2.0.6-tiger/test: testrumble
Only in SDL2-2.0.6-tiger/test: testrumble.dSYM
Only in SDL2-2.0.6-tiger/test: testscale
Only in SDL2-2.0.6-tiger/test: testscale.dSYM
Only in SDL2-2.0.6-tiger/test: testsem
Only in SDL2-2.0.6-tiger/test: testsem.dSYM
Only in SDL2-2.0.6-tiger/test: testshader
Only in SDL2-2.0.6-tiger/test: testshader.dSYM
Only in SDL2-2.0.6-tiger/test: testshape
Only in SDL2-2.0.6-tiger/test: testshape.dSYM
Only in SDL2-2.0.6-tiger/test: testsprite2
Only in SDL2-2.0.6-tiger/test: testsprite2.dSYM
Only in SDL2-2.0.6-tiger/test: testspriteminimal
Only in SDL2-2.0.6-tiger/test: testspriteminimal.dSYM
Only in SDL2-2.0.6-tiger/test: teststreaming
Only in SDL2-2.0.6-tiger/test: teststreaming.dSYM
Only in SDL2-2.0.6-tiger/test: testthread
Only in SDL2-2.0.6-tiger/test: testthread.dSYM
Only in SDL2-2.0.6-tiger/test: testtimer
Only in SDL2-2.0.6-tiger/test: testtimer.dSYM
Only in SDL2-2.0.6-tiger/test: testver
Only in SDL2-2.0.6-tiger/test: testver.dSYM
Only in SDL2-2.0.6-tiger/test: testviewport
Only in SDL2-2.0.6-tiger/test: testviewport.dSYM
Only in SDL2-2.0.6-tiger/test: testvulkan
Only in SDL2-2.0.6-tiger/test: testvulkan.dSYM
Only in SDL2-2.0.6-tiger/test: testwm2
Only in SDL2-2.0.6-tiger/test: testwm2.dSYM
Only in SDL2-2.0.6-tiger/test: torturethread
Only in SDL2-2.0.6-tiger/test: torturethread.dSYM
